

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Documentation &mdash; Levitate Python Toolbox 0.5.0.dev documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Examples" href="examples.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Levitate Python Toolbox
          

          
          </a>

          
            
            
              <div class="version">
                0.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="package.html">Package Organization and Functionality</a><ul>
<li class="toctree-l2"><a class="reference internal" href="package.html#models">Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="package.html#algorithms">Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="package.html#visualization">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="package.html#workflow">Workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples.html#basic-trap">Basic Trap</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#field-superposition">Field Superposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#complex-setups">Complex Setups</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.transducers">Transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.algorithms">Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.optimization">Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.visualize">Visualization</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Levitate Python Toolbox</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API Documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api_docs.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-documentation">
<span id="api-docs"></span><h1>API Documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-levitate.arrays">
<span id="arrays"></span><h2>Arrays<a class="headerlink" href="#module-levitate.arrays" title="Permalink to this headline">¶</a></h2>
<p>Handling of transducer arrays.</p>
<p>The primary base class is the <a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code></a> class, which contains the most
frequently used methods.</p>
<dl class="class">
<dt id="levitate.arrays.DoublesidedArray">
<em class="property">class </em><code class="descclassname">levitate.arrays.</code><code class="descname">DoublesidedArray</code><span class="sig-paren">(</span><em>ctype</em>, <em>separation</em>, <em>offset=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>rotation=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.DoublesidedArray" title="Permalink to this definition">¶</a></dt>
<dd><p>TransducerArray implementation for doublesided arrays.</p>
<p>Creates a doublesided array based on mirroring a singlesided array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ctype</strong> (Subclass of <a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code></a>) – A class representing a singlesided array. Needs to implement <a class="reference internal" href="#levitate.arrays.DoublesidedArray.grid_generator" title="levitate.arrays.DoublesidedArray.grid_generator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_generator</span></code></a>.</li>
<li><strong>separation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The distance between the two halves, along the normal.</li>
<li><strong>offset</strong> (<em>array_like</em><em>, </em><em>3 elements</em>) – The placement of the center between the two arrays.</li>
<li><strong>normal</strong> (<em>array_like</em><em>, </em><em>3 elements</em>) – The normal of the first half.</li>
<li><strong>rotation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 0</em>) – The rotation around the normal of the first half.</li>
<li><strong>**kwargs</strong> – Remaining arguments will be passed to the initializer for the singlesided array.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.arrays.DoublesidedArray.doublesided_signature">
<code class="descname">doublesided_signature</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.DoublesidedArray.doublesided_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the doublesided trap signature.</p>
<p>The doublesided trap signature should be added to focusing phases for a specific point
in order to create a trap at that location. The doublesided signature phase shifts
the elements in one side of the array by pi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>signature</strong> (<em>numpy.ndarray</em>) – The doublesided signature.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="levitate.arrays.DoublesidedArray.grid_generator">
<em class="property">classmethod </em><code class="descname">grid_generator</code><span class="sig-paren">(</span><em>separation=None</em>, <em>offset=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>rotation=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.DoublesidedArray.grid_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a double sided transducer grid.</p>
<p>See <a class="reference internal" href="#levitate.arrays.DoublesidedArray" title="levitate.arrays.DoublesidedArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DoublesidedArray</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>positions</strong> (<em>numpy.ndarray</em>) – 3xN array with the positions of the elements.</li>
<li><strong>normals</strong> (<em>numpy.ndarray</em>) – 3xN array with the normals of the elements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.arrays.RectangularArray">
<em class="property">class </em><code class="descclassname">levitate.arrays.</code><code class="descname">RectangularArray</code><span class="sig-paren">(</span><em>shape=16</em>, <em>spread=0.01</em>, <em>offset=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>rotation=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray" title="Permalink to this definition">¶</a></dt>
<dd><p>TransducerArray implementation for rectangular arrays.</p>
<p>Defines the locations and normals of elements (transducers) in an array.
For rotated arrays, the rotation is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A grid of the correct layout is crated in the xy-plane</li>
<li>The grid is rotated to the desired plane, as defined by the normal.</li>
<li>The grid is rotated around the normal.</li>
</ol>
</div></blockquote>
<p>The rotation to the desired plane is around the line where the desired
plane intersects with the xy-plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em> or </em><em>(</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>)</em><em>, </em><em>default 16</em>) – The number of transducer elements. Passing a single int will create a square array.</li>
<li><strong>spread</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 10e-3</em>) – The distance between the array elements.</li>
<li><strong>offset</strong> (<em>3 element array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>, </em><em>0</em><em>, </em><em>0</em><em>)</em>) – The location of the center of the array.</li>
<li><strong>normal</strong> (<em>3 element array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>, </em><em>0</em><em>, </em><em>1</em><em>)</em>) – The normal of all elements in the array.</li>
<li><strong>rotation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 0</em>) – The in-plane rotation of the array around the normal.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.arrays.RectangularArray.bottle_signature">
<code class="descname">bottle_signature</code><span class="sig-paren">(</span><em>position=(0</em>, <em>0)</em>, <em>radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray.bottle_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bottle trap signature.</p>
<p>The bottle trap signature should be added to focusing phases for a specific point
in order to create a bottle trap at that location. The bottle signature phase shifts
the elements in the array according to their distance from the center, creating
an inner zone and an outer zone of equal area with a relative shift of pi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>position</strong> (<em>array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>, </em><em>0</em><em>)</em>) – The center position for the signature.</li>
<li><strong>radius</strong> (<em>numeric</em><em>, </em><em>optional</em>) – A custom radius to use for the division of transducers.
The default is to use equal area partition based on the rectangular
area occupied by each transducer. This gives the same number of transducers
in the two groups for square arrays.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>signature</strong> (<em>numpy.ndarray</em>) – The bottle signature.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">This is not at all working for arrays where the normal is not (0, 0, 1).</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="levitate.arrays.RectangularArray.grid_generator">
<em class="property">classmethod </em><code class="descname">grid_generator</code><span class="sig-paren">(</span><em>shape=None</em>, <em>spread=None</em>, <em>offset=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>rotation=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray.grid_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a grid with positions and normals.</p>
<p>See <a class="reference internal" href="#levitate.arrays.RectangularArray" title="levitate.arrays.RectangularArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RectangularArray</span></code></a> for parameters and description.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>positions</strong> (<em>numpy.ndarray</em>) – The positions of the array elements, shape 3xN.</li>
<li><strong>normals</strong> (<em>numpy.ndarray</em>) – The normals of the array elements, shape 3xN.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.RectangularArray.twin_signature">
<code class="descname">twin_signature</code><span class="sig-paren">(</span><em>position=(0</em>, <em>0)</em>, <em>angle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray.twin_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the twin trap signature.</p>
<p>The twin trap signature should be added to focusing phases for a specific point
in order to create a twin trap at that location. The twin signature shifts the
phase of half of the elements by pi, splitting the array along a straight line.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>position</strong> (<em>array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>, </em><em>0</em><em>)</em>) – The center position for the signature, the line goes through this point.</li>
<li><strong>angle</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em>) – The angle between the x-axis and the dividing line.
Default is to create a line perpendicular to the line from the center of the array
to <code class="xref py py-obj docutils literal notranslate"><span class="pre">position</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>signature</strong> (<em>numpy.ndarray</em>) – The twin signature.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">This is not at all working for arrays where the normal is not (0, 0, 1).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.RectangularArray.vortex_signature">
<code class="descname">vortex_signature</code><span class="sig-paren">(</span><em>position=(0</em>, <em>0)</em>, <em>angle=0</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray.vortex_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the vortex trap signature.</p>
<p>The vortex trap signature should be added to focusing phases for a specific point
in order to create a vortex trap at that location. The vortex signature phase shifts
the elements in the array according to their angle in the coordinate plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>position</strong> (<em>array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>, </em><em>0</em><em>)</em>) – The center position for the signature.</li>
<li><strong>angle</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 0</em>) – An angle which will be added to the rotation, in radians.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>signature</strong> (<em>numpy.ndarray</em>) – The vortex signature.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">This is not at all working for arrays where the normal is not (0, 0, 1).</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.arrays.TransducerArray">
<em class="property">class </em><code class="descclassname">levitate.arrays.</code><code class="descname">TransducerArray</code><span class="sig-paren">(</span><em>transducer_positions</em>, <em>transducer_normals</em>, <em>transducer_model=None</em>, <em>transducer_size=0.01</em>, <em>transducer_kwargs=None</em>, <em>medium=&lt;levitate.materials.Material object&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class to handle transducer arrays.</p>
<p>This class has no notion of the layout. If possible, try to use a more specific
implementation instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>transducer_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The positions of the transducer elements in the array, shape 3xN.</li>
<li><strong>transducer_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The normals of the transducer elements in the array, shape 3xN.</li>
<li><strong>transducer_model</strong> – An object of <a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">levitate.transducers.TransducerModel</span></code></a> or a subclass. If passed a class it will create a new instance.</li>
<li><strong>transducer_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Fallback transducer size if no transducer model object is given, or if no grid is given.</li>
<li><strong>transducer_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – Extra keyword arguments used when instantiating a new transducer model.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>phases</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The phases of the transducer elements.</li>
<li><strong>amplitudes</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The amplitudes of the transducer elements.</li>
<li><a class="reference internal" href="#levitate.arrays.TransducerArray.complex_amplitudes" title="levitate.arrays.TransducerArray.complex_amplitudes"><strong>complex_amplitudes</strong></a> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – Transducer element controls on complex form.</li>
<li><strong>num_transducers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The number of transducers used.</li>
<li><strong>transducer_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – As above.</li>
<li><strong>transducer_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – As above.</li>
<li><strong>transducer_model</strong> (<a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">levitate.transducers.TransducerModel</span></code></a>) – An instance of a specific transducer model implementation.</li>
<li><strong>calculate</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator" title="levitate.arrays.TransducerArray.PersistentFieldEvaluator"><em>PersistentFieldEvaluator</em></a>) – Use to perform cashed field calculations.</li>
<li><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Frequency of the transducer model.</li>
<li><strong>omega</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Angular frequency of the transducer model.</li>
<li><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wavenumber in air, corresponding to <code class="xref py py-obj docutils literal notranslate"><span class="pre">freq</span></code>.</li>
<li><strong>wavelength</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wavelength in air, corresponding to <code class="xref py py-obj docutils literal notranslate"><span class="pre">freq</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator">
<em class="property">class </em><code class="descname">PersistentFieldEvaluator</code><span class="sig-paren">(</span><em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of cashed field calculations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code></a>) – The array of which to calculate the fields.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.force">
<code class="descname">force</code><span class="sig-paren">(</span><em>positions</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.force" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the force field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to calculate the force, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>force</strong> (<em>numpy.ndarray</em>) – The vector radiation force, shape (3, …) as the positions.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.pressure">
<code class="descname">pressure</code><span class="sig-paren">(</span><em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the pressure field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to calculate the pressure, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>pressure</strong> (<em>numpy.ndarray</em>) – The complex pressure amplitudes, shape (…) as the positions.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Cashed wrapper around <a class="reference internal" href="#levitate.arrays.TransducerArray.spatial_derivatives" title="levitate.arrays.TransducerArray.spatial_derivatives"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray.spatial_derivatives</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>positions</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.stiffness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the stiffness field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to calculate the stiffness, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>force</strong> (<em>numpy.ndarray</em>) – The radiation stiffness, shape (…) as the positions.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.velocity">
<code class="descname">velocity</code><span class="sig-paren">(</span><em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the velocity field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to calculate the velocity, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>velocity</strong> (<em>numpy.ndarray</em>) – The complex vector particle velocity, shape (3, …) as the positions.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="levitate.arrays.TransducerArray.complex_amplitudes">
<code class="descname">complex_amplitudes</code><a class="headerlink" href="#levitate.arrays.TransducerArray.complex_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>Transducer element controls on complex form.</p>
<p>The complex form of the transducer element controls is a convenience form.
The returned value will be calculated from the normal phases and amplitudes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Do not try to set a single complex element as <code class="xref py py-obj docutils literal notranslate"><span class="pre">array.complex_amplitudes[0]</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1j</span></code>.
It will not change the underlining phases and amplitudes, only the temporary complex numpy array.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.focus_phases">
<code class="descname">focus_phases</code><span class="sig-paren">(</span><em>focus</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.focus_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Focuses the phases to create a focus point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>focus</strong> (<em>array_like</em>) – Three element array with a location where to focus.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>phases</strong> (<em>numpy.ndarray</em>) – Array with the phases for the transducer elements.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.signature">
<code class="descname">signature</code><span class="sig-paren">(</span><em>focus</em>, <em>phases=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the phase signature of the array.</p>
<p>The signature of an array if the phase of the transducer elements
when the phase required to focus all elements to a specific point
has been removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>focus</strong> (<em>array_like</em>) – Three element array with a location for where the signature is relative to.</li>
<li><strong>phases</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a><em>, </em><em>optional</em>) – The phases of which to calculate the signature.
Will default to the current phases in the array.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>signature</strong> (<em>numpy.ndarray</em>) – The signature wrapped to the interval [-pi, pi].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives for all the transducers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the derivatives, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>ndarray</em>) – Array with the calculated derivatives. Has the shape (M, N, …) where M is the number of spatial derivatives,
and N is the number of transducers, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>,
and the remaining dimensions are the same as the <code class="xref py py-obj docutils literal notranslate"><span class="pre">positions</span></code> input with the first dimension removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-levitate.transducers">
<span id="transducers"></span><h2>Transducers<a class="headerlink" href="#module-levitate.transducers" title="Permalink to this headline">¶</a></h2>
<p>Handling of individual transducers and their directivities.</p>
<dl class="class">
<dt id="levitate.transducers.CircularPiston">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">CircularPiston</code><span class="sig-paren">(</span><em>effective_radius</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularPiston" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular piston transducer model.</p>
<p>Implementation of the circular piston directivity <span class="math notranslate nohighlight">\(D(\theta) = 2 J_1(ka\sin\theta) / (ka\sin\theta)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>effective_radius</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The radius <span class="math notranslate nohighlight">\(a\)</span> in the above.</li>
<li><strong>**kwargs</strong> – See <a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerModel</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.transducers.CircularPiston.directivity">
<code class="descname">directivity</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularPiston.directivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Returns <span class="math notranslate nohighlight">\(D(\theta) = 2 J_1(ka\sin\theta) / (ka\sin\theta)\)</span>
where <span class="math notranslate nohighlight">\(a\)</span> is the <code class="xref py py-obj docutils literal notranslate"><span class="pre">effective_radius</span></code> of the transducer,
<span class="math notranslate nohighlight">\(k\)</span> is the wavenumber of the transducer (<code class="xref py py-obj docutils literal notranslate"><span class="pre">k</span></code>),
<span class="math notranslate nohighlight">\(\theta\)</span> is the angle between the transducer normal
and the vector from the transducer to the receiving point,
and and <span class="math notranslate nohighlight">\(J_1\)</span> is the first order Bessel function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The amplitude (and phase) of the directivity, shape (…) as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.CircularRing">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">CircularRing</code><span class="sig-paren">(</span><em>effective_radius</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular ring transducer model.</p>
<p>Implementation of the circular ring directivity <span class="math notranslate nohighlight">\(D(\theta) = J_0(ka\sin\theta)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>effective_radius</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The radius <span class="math notranslate nohighlight">\(a\)</span> in the above.</li>
<li><strong>**kwargs</strong> – See <a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerModel</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.transducers.CircularRing.directivity">
<code class="descname">directivity</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing.directivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Returns <span class="math notranslate nohighlight">\(D(\theta) = J_0(ka\sin\theta)\)</span> where
<span class="math notranslate nohighlight">\(a\)</span> is the <code class="xref py py-obj docutils literal notranslate"><span class="pre">effective_radius</span></code> of the transducer,
<span class="math notranslate nohighlight">\(k\)</span> is the wavenumber of the transducer (<code class="xref py py-obj docutils literal notranslate"><span class="pre">k</span></code>),
<span class="math notranslate nohighlight">\(\theta\)</span> is the angle between the transducer normal
and the vector from the transducer to the receiving point,
and <span class="math notranslate nohighlight">\(J_0\)</span> is the zeroth order Bessel function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The amplitude (and phase) of the directivity, shape (…) as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.CircularRing.directivity_derivatives">
<code class="descname">directivity_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing.directivity_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the directivity.</p>
<p>Explicit implementation of the derivatives of the directivity, based
on analytical differentiation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.PlaneWaveTransducer">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">PlaneWaveTransducer</code><span class="sig-paren">(</span><em>freq=40000.0</em>, <em>p0=6</em>, <em>medium=&lt;levitate.materials.Material object&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PlaneWaveTransducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing planar waves.</p>
<p>This is not representing a physical transducer per se, but a traveling
plane wave.</p>
<dl class="method">
<dt id="levitate.transducers.PlaneWaveTransducer.greens_function">
<code class="descname">greens_function</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PlaneWaveTransducer.greens_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the pressure at a point.</p>
<p>The equation is that of a plane wave, <span class="math notranslate nohighlight">\(G(\vec x) = p_0 \exp(j\vec k \cdot \vec x)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The pressure at the locations, shape (…) as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.PlaneWaveTransducer.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PlaneWaveTransducer.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the greens function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M, …) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.ReflectingTransducer">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">ReflectingTransducer</code><span class="sig-paren">(</span><em>ctype</em>, <em>plane_distance</em>, <em>plane_normal=(0</em>, <em>0</em>, <em>1)</em>, <em>reflection_coefficient=1</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.ReflectingTransducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Metaclass for transducers with planar reflectors.</p>
<p>This class can be used to add reflectors to all transducer models.
This uses the image source method, so only infinite planar reflectors are
possible.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ctype</strong> (<em>class</em>) – The class implementing the transducer model.</li>
<li><strong>plane_distance</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The distance between the array and the reflector, along the normal.</li>
<li><strong>plane_normal</strong> (<em>array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>,</em><em>0</em><em>,</em><em>1</em><em>)</em>) – 3 element vector with the plane normal.</li>
<li><strong>reflection_coefficient</strong> (<em>complex float</em><em>, </em><em>default 1</em>) – Reflection coefficient to tune the magnitude and phase of the reflection.</li>
<li><strong>*args</strong> – Passed to ctype initializer</li>
<li><strong>**kwargs</strong> – Passed to ctype initializer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>transducer</em> – An object of a dynamically created class, inheriting from ReflectingTransducer and ctype.</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.transducers.ReflectingTransducer.greens_function">
<code class="descname">greens_function</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.ReflectingTransducer.greens_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the transducer radiation.</p>
<p>This evaluates the Green’s function for the underlying transducer model,
using the main source and the image source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The pressure at the locations, shape (…) as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.ReflectingTransducer.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.ReflectingTransducer.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the transducer radiation.</p>
<p>This calculates the spatial derivatives for the underlying transducer model,
using the main source and the image source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.TransducerModel">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">TransducerModel</code><span class="sig-paren">(</span><em>freq=40000.0</em>, <em>p0=6</em>, <em>medium=&lt;levitate.materials.Material object&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for ultrasonic single frequency transducers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 40 kHz</em>) – The resonant frequency of the transducer.</li>
<li><strong>p0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 6 Pa</em>) – The sound pressure crated at maximum amplitude at 1m distance, in Pa.
Note: This is not an rms value!</li>
<li><strong>**kwargs</strong> – All remaining arguments will be used as additional properties for the object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wavenumber in air.</li>
<li><strong>wavelength</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wavelength in air.</li>
<li><strong>omega</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Angular frequency.</li>
<li><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wave frequency.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.transducers.TransducerModel.directivity">
<code class="descname">directivity</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.directivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Subclasses will preferably implement this to create new directivity models.
Default implementation is omnidirectional sources.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The amplitude (and phase) of the directivity, shape (…) as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.directivity_derivatives">
<code class="descname">directivity_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.directivity_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the directivity.</p>
<p>The default implementation uses finite difference stencils to evaluate the
derivatives. In principle this means that customized directivity models
does not need to implement their own derivatives, but can do so for speed
and precision benefits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.greens_function">
<code class="descname">greens_function</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.greens_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the transducer radiation.</p>
<p>This is a combination of spherically spreading waves, a directivity
function, and a source strength.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The pressure at the locations, shape (…) as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the greens function.</p>
<p>This is the combination of the derivative of the spherical spreading, and
the derivatives of the directivity, including source strength.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M, …) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.spherical_derivatives">
<code class="descname">spherical_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>receiver_positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.spherical_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the spherical spreading.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.spherical_spreading">
<code class="descname">spherical_spreading</code><span class="sig-paren">(</span><em>source_position</em>, <em>receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.spherical_spreading" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate spherical wavefronts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation, shape (3, …).
The first dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The amplitude and phase of the wavefront, shape (…) as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_positions</span></code>.
Assuming 1Pa at 1m distance, phase referenced to the transducer center.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-levitate.algorithms">
<span id="algorithms"></span><h2>Algorithms<a class="headerlink" href="#module-levitate.algorithms" title="Permalink to this headline">¶</a></h2>
<p>A collection of levitation related mathematical implementations.</p>
<dl class="function">
<dt id="levitate.algorithms.gorkov_divergence">
<code class="descclassname">levitate.algorithms.</code><code class="descname">gorkov_divergence</code><span class="sig-paren">(</span><em>array</em>, <em>radius_sphere=0.001</em>, <em>sphere_material=&lt;levitate.materials.Material object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.algorithms.gorkov_divergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Create gorkov divergence calculation functions.</p>
<p>Creates functions which calculates the gorkov divergence and the jacobian of
the field specified using spaial derivatives of the pressure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array.</li>
<li><strong>radius_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 1e-3</em>) – Radius of the spherical beads.</li>
<li><strong>sphere_material</strong> (<em>Material</em>) – The material of the sphere, default Styrofoam.</li>
<li><strong>weights</strong> (<em>numeric</em><em>, </em><em>optional</em>) – Attaching weights to the algorithms for use in optimizations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>calc_values</strong> (<em>func</em>) – Function to calculate the divergence of the gorkov potential in cartesian coordinates.</li>
<li><strong>calc_jacobians</strong> (<em>func</em>) – Function to calculate the jacobian of the above, w.r.t the transducers.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.algorithms.gorkov_laplacian">
<code class="descclassname">levitate.algorithms.</code><code class="descname">gorkov_laplacian</code><span class="sig-paren">(</span><em>array</em>, <em>radius_sphere=0.001</em>, <em>sphere_material=&lt;levitate.materials.Material object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.algorithms.gorkov_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Create gorkov laplacian calculation functions.</p>
<p>Creates functions which calculates the laplacian of the gorkov potential
and the jacobian of the field specified using spaial derivatives of the pressure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array.</li>
<li><strong>radius_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 1e-3</em>) – Radius of the spherical beads.</li>
<li><strong>sphere_material</strong> (<em>Material</em>) – The material of the sphere, default Styrofoam.</li>
<li><strong>weights</strong> (<em>numeric</em><em>, </em><em>optional</em>) – Attaching weights to the algorithms for use in optimizations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>calc_values</strong> (<em>func</em>) – Function to calculate the divergence of the gorkov potential in cartesian coordinates.</li>
<li><strong>calc_jacobians</strong> (<em>func</em>) – Function to calculate the jacobian of the above, w.r.t the transducers.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.algorithms.pressure_squared_magnitude">
<code class="descclassname">levitate.algorithms.</code><code class="descname">pressure_squared_magnitude</code><span class="sig-paren">(</span><em>array=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.algorithms.pressure_squared_magnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Create pressure squared magnitude calculation functions.</p>
<p>Creates functions which calculates the squared pressure magnitude,
and the corresponding jacobians.
The main use of this is to use as a cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array, optional.</li>
<li><strong>weights</strong> (<em>numeric</em><em>, </em><em>optional</em>) – Attaching weights to the algorithms for use in optimizations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>calc_values</strong> (<em>func</em>) – Function to calculate the divergence of the gorkov potential in cartesian coordinates.</li>
<li><strong>calc_jacobians</strong> (<em>func</em>) – Function to calculate the jacobian of the above, w.r.t the transducers.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.algorithms.second_order_force">
<code class="descclassname">levitate.algorithms.</code><code class="descname">second_order_force</code><span class="sig-paren">(</span><em>array</em>, <em>radius_sphere=0.001</em>, <em>sphere_material=&lt;levitate.materials.Material object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.algorithms.second_order_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Create second order radiation force calculation functions.</p>
<p>Creates functions which calculates the radiation force on a sphere generated
by the field specified using spaial derivatives of the pressure, and the
corresponding jacobians.</p>
<p>This is more suitable than the Gor’kov formulation for use with progressive
wave fiends, e.g. single sided arrays, see <a class="reference external" href="https://doi.org/10.1121/1.4773924">https://doi.org/10.1121/1.4773924</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array.</li>
<li><strong>radius_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 1e-3</em>) – Radius of the spherical beads.</li>
<li><strong>sphere_material</strong> (<em>Material</em>) – The material of the sphere, default Styrofoam.</li>
<li><strong>weights</strong> (<em>numeric</em><em>, </em><em>optional</em>) – Attaching weights to the algorithms for use in optimizations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>calc_values</strong> (<em>func</em>) – Function to calculate the divergence of the gorkov potential in cartesian coordinates.</li>
<li><strong>calc_jacobians</strong> (<em>func</em>) – Function to calculate the jacobian of the above, w.r.t the transducers.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.algorithms.second_order_stiffness">
<code class="descclassname">levitate.algorithms.</code><code class="descname">second_order_stiffness</code><span class="sig-paren">(</span><em>array</em>, <em>radius_sphere=0.001</em>, <em>sphere_material=&lt;levitate.materials.Material object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.algorithms.second_order_stiffness" title="Permalink to this definition">¶</a></dt>
<dd><p>Create second order radiation stiffness calculation functions.</p>
<p>Creates functions which calculates the radiation stiffness on a sphere
generated by the field specified using spaial derivatives of
the pressure, and the corresponding jacobians.</p>
<p>This is more suitable than the Gor’kov formulation for use with progressive
wave fiends, e.g. single sided arrays, see <a class="reference external" href="https://doi.org/10.1121/1.4773924">https://doi.org/10.1121/1.4773924</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array.</li>
<li><strong>radius_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 1e-3</em>) – Radius of the spherical beads.</li>
<li><strong>sphere_material</strong> (<em>Material</em>) – The material of the sphere, default Styrofoam.</li>
<li><strong>weights</strong> (<em>numeric</em><em>, </em><em>optional</em>) – Attaching weights to the algorithms for use in optimizations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>calc_values</strong> (<em>func</em>) – Function to calculate the divergence of the gorkov potential in cartesian coordinates.</li>
<li><strong>calc_jacobians</strong> (<em>func</em>) – Function to calculate the jacobian of the above, w.r.t the transducers.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.algorithms.vector_target">
<code class="descclassname">levitate.algorithms.</code><code class="descname">vector_target</code><span class="sig-paren">(</span><em>vector_calculator</em>, <em>target_vector=(0</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.algorithms.vector_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function which calculates the difference of a vector and a target vector.</p>
<p>This is probably only usable as a cost function, where the goal is to minimize
<span class="math notranslate nohighlight">\(||(v - v_0)||^2_w\)</span>, i.e. the weighted square norm between a varying
vector and a fixed vector. Note that the values in the weights will NOT be squared,
i.e. have the inverse unit squares compared to the two vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vector_calculator</strong> (<em>(</em><em>callable</em><em>, </em><em>callable</em><em>)</em>) – A tuple of callables where the first callable calculate the vector values,
and the second callable calculate the jacobians of the vector.
This fits with the output format of the other algorithms in this module.</li>
<li><strong>targert_vector</strong> (<em>3 element numeric</em><em>, </em><em>default</em><em> (</em><em>0</em><em>, </em><em>0</em><em>, </em><em>0</em><em>)</em>) – The target vector <span class="math notranslate nohighlight">\(v_0\)</span> above.</li>
<li><strong>weights</strong> (<em>numeric</em><em>, </em><em>optional</em>) – Attaching weights to the algorithms for use in optimizations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>calc_values</strong> (<em>func</em>) – Function to calculate the divergence of the gorkov potential in cartesian coordinates.</li>
<li><strong>calc_jacobians</strong> (<em>func</em>) – Function to calculate the jacobian of the above, w.r.t the transducers.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.algorithms.velocity_squared_magnitude">
<code class="descclassname">levitate.algorithms.</code><code class="descname">velocity_squared_magnitude</code><span class="sig-paren">(</span><em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.algorithms.velocity_squared_magnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Create velocity squared magnitude calculation functions.</p>
<p>Creates functions which calculates the squared velocity magnitude,
as a vector, and the corresponding jacobians.
The main use of this is to use as a cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array.</li>
<li><strong>weights</strong> (<em>numeric</em><em>, </em><em>optional</em>) – Attaching weights to the algorithms for use in optimizations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>calc_values</strong> (<em>func</em>) – Function to calculate the divergence of the gorkov potential in cartesian coordinates.</li>
<li><strong>calc_jacobians</strong> (<em>func</em>) – Function to calculate the jacobian of the above, w.r.t the transducers.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-levitate.optimization">
<span id="optimization"></span><h2>Optimization<a class="headerlink" href="#module-levitate.optimization" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="levitate.optimization.CostFunctionPoint">
<em class="property">class </em><code class="descclassname">levitate.optimization.</code><code class="descname">CostFunctionPoint</code><span class="sig-paren">(</span><em>position</em>, <em>array</em>, <em>*funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.optimization.CostFunctionPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for evaluating algorithms as cost functions.</p>
<p>Since the algorithms has some shared requirements as the inputs, the sound
field attributes is evaluated only once for a single point in space.
To use an algorithm as a cost funciton, the function needs to have a <code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code>
attribute. If the algorithm generator functions are called with a <code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code>
parameter it will be added as an attribure of the function objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>position</strong> (<em>3 element numeric</em>) – The position at which to evaluate the cost functions.</li>
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The array for which to optimize.</li>
<li><strong>*funcs</strong> (<em>pairs of callables</em>) – Pairs (calc_values, calc_jacobians) of callables representing the cost functions.
Each callable should have a ‘requires’ property and a ‘weights’ property.
See the algorithms module for more details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.optimization.CostFunctionPoint.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>complex_transducer_weights</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.optimization.CostFunctionPoint.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the cost function point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>complex_transducer_weights</strong> (<em>complex ndarray</em>) – The complex weights (amplitudes) of the transducer elements in the array.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>value</strong> (<em>float</em>) – The summed and weighted cost function results.</li>
<li><strong>jacobians</strong> (<em>compelex ndarray</em>) – The derivatives of the cost function value, w.r.t. the transducers
as defined in the supplementary documentation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="levitate.optimization.minimize">
<code class="descclassname">levitate.optimization.</code><code class="descname">minimize</code><span class="sig-paren">(</span><em>functions</em>, <em>array</em>, <em>start_values=None</em>, <em>use_real_imag=False</em>, <em>constrain_transducers=None</em>, <em>variable_amplitudes=False</em>, <em>callback=None</em>, <em>precall=None</em>, <em>basinhopping=False</em>, <em>minimize_kwargs=None</em>, <em>return_optim_status=False</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.optimization.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimizes a set of cost functions.</p>
<p>Each cost function should have the signature <code class="xref py py-obj docutils literal notranslate"><span class="pre">f(complex_amplitudes)</span></code>
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_amplitudes</span></code> is an ndarray with weight of each element in the array.
The functions should return <code class="xref py py-obj docutils literal notranslate"><span class="pre">value,</span> <span class="pre">jacobians</span></code> where the jacobians are the
derivatives of the value w.r.t the transducers as defined in the full documentation.</p>
<p>This function supports minimization sequences. Pass an iterable of iterables
of cost functions to start sequenced minimization, e.g. a list of lists of
functions.
When using multiple cost functions, either all functions return the
jacobians, or no functions return jacobians.
The arguments: <code class="xref py py-obj docutils literal notranslate"><span class="pre">use_real_imag</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">variable_amplitudes</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">constrain_transducers</span></code>,
<code class="xref py py-obj docutils literal notranslate"><span class="pre">callback</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">precall</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">basinhopping</span></code>, and  <code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize_kwargs</span></code> can be given as single
values or as iterables of the same length as <code class="xref py py-obj docutils literal notranslate"><span class="pre">functions</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>functions</strong> – The cost functions that should be minimized. A single callable, an
iterable of callables, or an iterable of iterables of callables, as
described above.</li>
<li><strong>array</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code>) – The array from which the cost functions are created.</li>
<li><strong>start_values</strong> (<em>complex ndarray</em><em>, </em><em>optional</em>) – The start values for the optimizatioin. Will default to the current array
settings if not given. Note that the precall for minimization sequences can
overrule this value.</li>
<li><strong>use_real_imag</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>default False</em>) – Toggles if the optimization should run using the phase-amplitude forumation
or the real-imag formulation.</li>
<li><strong>constrain_transducers</strong> (<em>array_like</em>) – Specifies a number of transducers which are constant elements in the
minimization. Will be used as the second argument in <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.delete</span></code></li>
<li><strong>variable_amplitudes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Toggles the usage of varying amplitudes in the minimization.
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">use_real_imag</span></code> is False ‘phases first’ is also a valid argument for this
parameter. The minimizer will then automatically sequence to optimize first with
fixed then with variable amplitudes, returning only the last result.</li>
<li><strong>callback</strong> (<em>callable</em>) – A callback function which will be called after each step in sequenced
minimization. Return false from the callback to break the sequence.
Should have the signature :
<code class="xref py py-obj docutils literal notranslate"><span class="pre">callback(array=array,</span> <span class="pre">result=result,</span> <span class="pre">optim_status=opt_res,</span> <span class="pre">idx=idx)</span></code></li>
<li><strong>precall</strong> (<em>callable</em>) – Initialization function which will be called with the array phases,
amplitudes, and the sequence index before each sequence step.
Must return the initial phases and amplitudes for the sequence step.
Default sets the phases and amplitudes to the solution of the previous
sequence step, or the original state for the first iteration.
Should have the signature :
<code class="xref py py-obj docutils literal notranslate"><span class="pre">precall(complex_amplitudes,</span> <span class="pre">idx)</span></code></li>
<li><strong>basinhopping</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Specifies if basinhopping should be used. Pass an int to specify the
number of basinhopping iterations, or True to use default value.</li>
<li><strong>return_optim_status</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Toggles the <code class="xref py py-obj docutils literal notranslate"><span class="pre">optim_status</span></code> output.</li>
<li><strong>minimize_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – Extra keyword arguments which will be passed to <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.minimize</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>result</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray</span></code>) – The array phases and amplitudes after minimization.
Stacks sequenced result in the first dimension.</li>
<li><strong>optim_status</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimizeResult</span></code>) – Scipy optimization result structure. Optional output,
toggle with the corresponding input argument.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-levitate.visualize">
<span id="visualization"></span><h2>Visualization<a class="headerlink" href="#module-levitate.visualize" title="Permalink to this headline">¶</a></h2>
<p>Visualization methods based on the plotly graphing library, and some connivance functions.</p>
<dl class="function">
<dt id="levitate.visualize.SPL">
<code class="descclassname">levitate.visualize.</code><code class="descname">SPL</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.SPL" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert sound pressure to sound pressure level.</p>
<p>Uses the standard reference value for airborne acoustics: 20 µPa.
Note that the input is the pressure amplitude, not he RMS value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> (<em>numeric</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.7)"><em>complex</em></a>) – The complex sound pressure amplitude.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>SPL</strong> (<em>numeric</em>) – The sound pressure level</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.visualize.SVL">
<code class="descclassname">levitate.visualize.</code><code class="descname">SVL</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.SVL" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert sound particle velocity to sound velocity level.</p>
<p>Uses the standard reference value for airborne acoustics: 50 nm/s,
which is approximately 20 µPa / c_0 / rho_0
Note that the input the velocity amplitude(s), not the RMS values.</p>
<p>If the first axis of the velocity input has length 3, it will be assumed to
be the three Cartesian components of the velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong> (<em>numeric</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.7)"><em>complex</em></a>) – The complex sound velocity amplitude, or the vector velocity.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>SVL</strong> (<em>numeric</em>) – The sound velocity level</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="levitate.visualize.Visualizer">
<em class="property">class </em><code class="descclassname">levitate.visualize.</code><code class="descname">Visualizer</code><span class="sig-paren">(</span><em>array</em>, <em>xlimits=None</em>, <em>ylimits=None</em>, <em>zlimits=None</em>, <em>resolution=10</em>, <em>constant_axis=('y'</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle array visualizations.</p>
<p>Two different style of plots are currently implemented: scalar field
visualizations and transducer visualizations. The methods return
plotly compatible dictionaries corresponding to a single trace.
The calculations are buffered, so the first plots are always slower
than successive plots. This also means that the memory usage is very large
for high-resolution plots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>array</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code>) – The transducer array to visualize.</li>
<li><strong>xlimits</strong> (<em>2 element array_like</em>) – Override for the default x limits</li>
<li><strong>ylimits</strong> (<em>2 element array_like</em>) – Override for the default y limits</li>
<li><strong>zlimits</strong> (<em>2 element array_like</em>) – Override for the default z limits</li>
<li><strong>resolution</strong> (<em>numeric</em><em>, </em><em>default 10</em>) – Resolution of the plots, in elements per wavelength.</li>
<li><strong>constant_axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – <code class="xref py py-obj docutils literal notranslate"><span class="pre">(axis,</span> <span class="pre">value)</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">axis</span></code> where <code class="xref py py-obj docutils literal notranslate"><span class="pre">axis</span></code> is in <code class="xref py py-obj docutils literal notranslate"><span class="pre">['x',</span> <span class="pre">'y',</span> <span class="pre">'z']</span></code> and indicates
which axis to keep constant in the plots. The value indicates at which value
the slice is taken. Default to <code class="xref py py-obj docutils literal notranslate"><span class="pre">('y',</span> <span class="pre">0)</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.visualize.Visualizer.find_trap">
<code class="descname">find_trap</code><span class="sig-paren">(</span><em>start_pos</em>, <em>tolerance=1e-05</em>, <em>time_interval=50</em>, <em>return_path=False</em>, <em>rho=25</em>, <em>radius=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.find_trap" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the approximate location of a levitation trap.</p>
<p>Find an approximate position of a acoustic levitation trap close to a starting point.
This is done by following the radiation force in the sound field using an differential
equation solver. The differential equation is the unphysical equation
<span class="math notranslate nohighlight">\(d\vec x/dt  = \vec F(x,t)\)</span>, i.e. interpreting the force field as a velocity field.
This works for finding the location of a trap and the field line from the starting position
to the trap position, but it can not be seen as a proper kinematic simulation of the system.</p>
<p>The solving of the above equation takes place until the whole time interval is covered,
or the tolerance is met. The tolerance is evaluated using the assumption that the force
is zero at the trap, evaluating the distance from the zero-force position using the force
gradient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start_pos</strong> (<em>array_like</em><em>, </em><em>3 elements</em>) – The starting point for the solving.</li>
<li><strong>tolerance</strong> (<em>numeric</em><em>, </em><em>default 10e-6</em>) – The approximate tolerance of the solution, i.e. how close should
the found position be to the true position, in meters.</li>
<li><strong>time_interval</strong> (<em>numeric</em><em>, </em><em>default 10</em>) – The unphysical time of the solution range in the differential equation above.</li>
<li><strong>return_path</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><em>default False</em>) – Controls if the path from the starting point to the found trap is returned.
Set to an int to specify the number of points in the path.</li>
<li><strong>rho</strong> (<em>numeric</em><em>, </em><em>default 25</em>) – The density of the spherical bead.</li>
<li><strong>radius</strong> (<em>numeric</em><em>, </em><em>default 1e-3</em>) – The radius of the spherical bead.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>trap_pos</strong> (<em>numpy.ndarray</em>) – The found trap position, or the path from the starting position to the trap position, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">return_path</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.visualize.Visualizer.pressure">
<code class="descname">pressure</code><span class="sig-paren">(</span><em>min=130</em>, <em>max=170</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize pressure field.</p>
</dd></dl>

<dl class="method">
<dt id="levitate.visualize.Visualizer.scalar_field">
<code class="descname">scalar_field</code><span class="sig-paren">(</span><em>calculator</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.scalar_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate and prepare a scalar field visualization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>calculator</strong> (<em>callable</em><em> or </em><em>iterable of callables</em>) – Callable which takes a mesh as input and returns data values for every point.
If an iterable is passed, the callables will be called with the output from the
previous callable, the first one called with the mesh.</li>
<li><strong>**kwargs</strong> – Remaining keyword arguments will be added to the trace dictionary, replacing defaults.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>trace</strong> (<em>dict</em>) – A plotly style dictionary with the trace for the field.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.visualize.Visualizer.transducers">
<code class="descname">transducers</code><span class="sig-paren">(</span><em>data=None</em>, <em>phases=None</em>, <em>amplitudes=None</em>, <em>signature_pos=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.transducers" title="Permalink to this definition">¶</a></dt>
<dd><p>Create transducer visualization.</p>
<p>A 3d scatter trace of the transducer elements in an array.
Uses the color of the elements to show data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code>) – The array to visualize.</li>
<li><strong>data</strong> (<em>'phase'</em><em>, </em><em>'amplitude'</em><em>, or </em><em>numeric</em>) – Which data to color the transducers with.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>trace</strong> (<em>dict</em>) – A plotly style dictionary with the trace for the transducers.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.visualize.Visualizer.velocity">
<code class="descname">velocity</code><span class="sig-paren">(</span><em>min=130</em>, <em>max=170</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize velocity field.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="levitate.visualize.dB">
<code class="descclassname">levitate.visualize.</code><code class="descname">dB</code><span class="sig-paren">(</span><em>x</em>, <em>power=False</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.dB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert ratio to decibels.</p>
<p>Converting a ratio to decibels depends on whether the ratio is a ratio
of amplitudes or a ratio of powers. For amplitudes the decibel value is
<span class="math notranslate nohighlight">\(20\log(|x|)\)</span>, while for power ratios the value is <span class="math notranslate nohighlight">\(10\log(|x|)\)</span>
where <span class="math notranslate nohighlight">\(\log\)</span> is the base 10 logarithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numeric</em>) – Linear amplitude or radio, can be complex.</li>
<li><strong>power</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>default False</em>) – Toggles if the ration is proportional to power.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>L</strong> (<em>numeric</em>) – The decibel value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="examples.html" class="btn btn-neutral float-left" title="Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Carl Andersson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>