

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Documentation &mdash; Levitate Python Toolbox 0.3.3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Examples" href="examples.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Levitate Python Toolbox
          

          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="package.html">Package Organization and Functionality</a><ul>
<li class="toctree-l2"><a class="reference internal" href="package.html#models">Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="package.html#algorithms">Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="package.html#visualization">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="package.html#workflow">Workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples.html#basic-trap">Basic Trap</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#field-superposition">Field Superposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#complex-setups">Complex Setups</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.transducers">Transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.cost_functions">Cost Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-levitate.visualize">Visualization</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Levitate Python Toolbox</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API Documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api_docs.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-documentation">
<span id="api-docs"></span><h1>API Documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-levitate.arrays">
<span id="arrays"></span><h2>Arrays<a class="headerlink" href="#module-levitate.arrays" title="Permalink to this headline">¶</a></h2>
<p>Handling of transducer arrays.</p>
<p>The primary base class is the <a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code></a> class, which contains the most
frequently used methods.</p>
<dl class="class">
<dt id="levitate.arrays.TransducerArray">
<em class="property">class </em><code class="descclassname">levitate.arrays.</code><code class="descname">TransducerArray</code><span class="sig-paren">(</span><em>transducer_positions</em>, <em>transducer_normals</em>, <em>transducer_model=None</em>, <em>transducer_size=0.01</em>, <em>transducer_kwargs=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class to handle transducer arrays.</p>
<p>This class has no notion of the layout. If possible, try to use a more specific
implementation instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>transducer_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The positions of the transducer elements in the array, shape Nx3.</li>
<li><strong>transducer_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The normals of the transducer elements in the array, shape Nx3.</li>
<li><strong>transducer_model</strong> – An object of <a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">levitate.transducers.TransducerModel</span></code></a> or a subclass. If passed a class it will create a new instance.</li>
<li><strong>transducer_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Fallback transducer size if no transducer model object is given, or if no grid is given.</li>
<li><strong>transducer_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – Extra keyword arguments used when instantiating a new transducer model.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>phases</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The phases of the transducer elements.</li>
<li><strong>amplitudes</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The amplitudes of the transducer elements.</li>
<li><a class="reference internal" href="#levitate.arrays.TransducerArray.complex_amplitudes" title="levitate.arrays.TransducerArray.complex_amplitudes"><strong>complex_amplitudes</strong></a> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – Transducer element controls on complex form.</li>
<li><strong>num_transducers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The number of transducers used.</li>
<li><strong>transducer_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – As above.</li>
<li><strong>transducer_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – As above.</li>
<li><strong>transducer_model</strong> (<a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">levitate.transducers.TransducerModel</span></code></a>) – An instance of a specific transducer model implementation.</li>
<li><strong>calculate</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator" title="levitate.arrays.TransducerArray.PersistentFieldEvaluator"><em>PersistentFieldEvaluator</em></a>) – Use to perform cashed field calculations.</li>
<li><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Frequency of the transducer model.</li>
<li><strong>omega</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Angular frequency of the transducer model.</li>
<li><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wavenumber in air, corresponding to <code class="xref py py-obj docutils literal notranslate"><span class="pre">freq</span></code>.</li>
<li><strong>wavelength</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wavelength in air, corresponding to <code class="xref py py-obj docutils literal notranslate"><span class="pre">freq</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="levitate.arrays.TransducerArray.complex_amplitudes">
<code class="descname">complex_amplitudes</code><a class="headerlink" href="#levitate.arrays.TransducerArray.complex_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>Transducer element controls on complex form.</p>
<p>The complex form of the transducer element controls is a convenience form.
The returned value will be calculated from the normal phases and amplitudes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Do not try to set a single complex element as <code class="xref py py-obj docutils literal notranslate"><span class="pre">array.complex_amplitudes[0]</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1j</span></code>.
It will not change the underlining phases and amplitudes, only the temporary complex numpy array.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.focus_phases">
<code class="descname">focus_phases</code><span class="sig-paren">(</span><em>focus</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.focus_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Focuses the phases to create a focus point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>focus</strong> (<em>array_like</em>) – Three element array with a location where to focus.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>phases</strong> (<em>numpy.ndarray</em>) – Array with the phases for the transducer elements.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.signature">
<code class="descname">signature</code><span class="sig-paren">(</span><em>focus</em>, <em>phases=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the phase signature of the array.</p>
<p>The signature of an array if the phase of the transducer elements
when the phase required to focus all elements to a specific point
has been removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>focus</strong> (<em>array_like</em>) – Three element array with a location for where the signature is relative to.</li>
<li><strong>phases</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a><em>, </em><em>optional</em>) – The phases of which to calculate the signature.
Will default to the current phases in the array.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>signature</strong> (<em>numpy.ndarray</em>) – The signature wrapped to the interval [-pi, pi].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>receiver_position</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives for all the transducers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the derivatives. The last dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>ndarray</em>) – Array with the calculated derivatives. Has the shape (M, N, …) M is the number of spatial derivatives,
where N is the number of transducers, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>,
and the remaining dimensions are the same as the <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> input with the last dimension removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator">
<em class="property">class </em><code class="descname">PersistentFieldEvaluator</code><span class="sig-paren">(</span><em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of cashed field calculations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code></a>) – The array of which to calculate the fields.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>positions</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Cashed wrapper around <a class="reference internal" href="#levitate.arrays.TransducerArray.spatial_derivatives" title="levitate.arrays.TransducerArray.spatial_derivatives"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray.spatial_derivatives</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.pressure">
<code class="descname">pressure</code><span class="sig-paren">(</span><em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the pressure field.</p>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.velocity">
<code class="descname">velocity</code><span class="sig-paren">(</span><em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the velocity field.</p>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.force">
<code class="descname">force</code><span class="sig-paren">(</span><em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.force" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the force field.</p>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.TransducerArray.PersistentFieldEvaluator.stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.TransducerArray.PersistentFieldEvaluator.stiffness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the stiffness field.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.arrays.RectangularArray">
<em class="property">class </em><code class="descclassname">levitate.arrays.</code><code class="descname">RectangularArray</code><span class="sig-paren">(</span><em>shape=16</em>, <em>spread=0.01</em>, <em>offset=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>rotation=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray" title="Permalink to this definition">¶</a></dt>
<dd><p>TransducerArray implementation for rectangular arrays.</p>
<p>Defines the locations and normals of elements (transducers) in an array.
For rotated arrays, the rotation is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A grid of the correct layout is crated in the xy-plane</li>
<li>The grid is rotated to the desired plane, as defined by the normal.</li>
<li>The grid is rotated around the normal.</li>
</ol>
</div></blockquote>
<p>The rotation to the desired plane is around the line where the desired
plane intersects with the xy-plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em> or </em><em>(</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>)</em><em>, </em><em>default 16</em>) – The number of transducer elements. Passing a single int will create a square array.</li>
<li><strong>spread</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default=10e-3</em>) – The distance between the array elements.</li>
<li><strong>offset</strong> (<em>3 element array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>,</em><em>0</em><em>,</em><em>0</em><em>)</em>) – The location of the center of the array.</li>
<li><strong>normal</strong> (<em>3 element array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>,</em><em>0</em><em>,</em><em>1</em><em>)</em>) – The normal of all elements in the array.</li>
<li><strong>rotation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 0</em>) – The in-plane rotation of the array around the normal.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="levitate.arrays.RectangularArray.grid_generator">
<em class="property">classmethod </em><code class="descname">grid_generator</code><span class="sig-paren">(</span><em>shape=None</em>, <em>spread=None</em>, <em>offset=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>rotation=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray.grid_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a grid with positions and normals.</p>
<p>See <a class="reference internal" href="#levitate.arrays.RectangularArray" title="levitate.arrays.RectangularArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RectangularArray</span></code></a> for parameters and description.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>positions</strong> (<em>numpy.ndarray</em>) – The positions of the array elements, shape Nx3.</li>
<li><strong>normals</strong> (<em>numpy.ndarray</em>) – The normals of the array elements, shape Nx3.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.RectangularArray.twin_signature">
<code class="descname">twin_signature</code><span class="sig-paren">(</span><em>position=(0</em>, <em>0)</em>, <em>angle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray.twin_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the twin trap signature.</p>
<p>The twin trap signature should be added to focusing phases for a specific point
in order to create a twin trap at that location. The twin signature shifts the
phase of half of the elements by pi, splitting the array along a straight line.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>angle</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The angle with which to rotate the signature.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>signature</strong> (<em>numpy.ndarray</em>) – The twin signature.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.RectangularArray.vortex_signature">
<code class="descname">vortex_signature</code><span class="sig-paren">(</span><em>position=(0</em>, <em>0)</em>, <em>angle=0</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray.vortex_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the vortex trap signature.</p>
<p>The vortex trap signature should be added to focusing phases for a specific point
in order to create a vortex trap at that location. The vortex signature phase shifts
the elements in the array according to their angle in the coordinate plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>signature</strong> (<em>numpy.ndarray</em>) – The vortex signature.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.arrays.RectangularArray.bottle_signature">
<code class="descname">bottle_signature</code><span class="sig-paren">(</span><em>position=(0</em>, <em>0)</em>, <em>radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.RectangularArray.bottle_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bottle trap signature.</p>
<p>The bottle trap signature should be added to focusing phases for a specific point
in order to create a bottle trap at that location. The bottle signature phase shifts
the elements in the array according to their distance from the center, creating
an inner zone and an outer zone of equal area with a relative shift of pi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>signature</strong> (<em>numpy.ndarray</em>) – The bottle signature.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.arrays.DoublesidedArray">
<em class="property">class </em><code class="descclassname">levitate.arrays.</code><code class="descname">DoublesidedArray</code><span class="sig-paren">(</span><em>ctype</em>, <em>separation</em>, <em>offset=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>rotation=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.DoublesidedArray" title="Permalink to this definition">¶</a></dt>
<dd><p>TransducerArray implementation for doublesided arrays.</p>
<p>Creates a doublesided array based on mirroring a singlesided array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ctype</strong> (Subclass of <a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code></a>) – A class representing a singlesided array. Needs to implement <a class="reference internal" href="#levitate.arrays.DoublesidedArray.grid_generator" title="levitate.arrays.DoublesidedArray.grid_generator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_generator</span></code></a>.</li>
<li><strong>separation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The distance between the two halves, along the normal.</li>
<li><strong>offset</strong> (<em>array_like</em><em>, </em><em>3 elements</em>) – The placement of the center between the two arrays.</li>
<li><strong>normal</strong> (<em>array_like</em><em>, </em><em>3 elements</em>) – The normal of the first half.</li>
<li><strong>rotation</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 0</em>) – The rotation around the normal of the first half.</li>
<li><strong>**kwargs</strong> – Remaining arguments will be passed to the initializer for the singlesided array.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="levitate.arrays.DoublesidedArray.grid_generator">
<em class="property">classmethod </em><code class="descname">grid_generator</code><span class="sig-paren">(</span><em>separation=None</em>, <em>offset=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>rotation=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.arrays.DoublesidedArray.grid_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a double sided transducer grid.</p>
<p>See <a class="reference internal" href="#levitate.arrays.DoublesidedArray" title="levitate.arrays.DoublesidedArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DoublesidedArray</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>positions</strong> (<em>numpy.ndarray</em>) – Nx3 array with the positions of the elements.</li>
<li><strong>normals</strong> (<em>numpy.ndarray</em>) – Nx3 array with the normals of the elements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-levitate.transducers">
<span id="transducers"></span><h2>Transducers<a class="headerlink" href="#module-levitate.transducers" title="Permalink to this headline">¶</a></h2>
<p>Handling of individual transducers and their directivities.</p>
<dl class="class">
<dt id="levitate.transducers.TransducerModel">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">TransducerModel</code><span class="sig-paren">(</span><em>freq=40000.0</em>, <em>p0=6</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for ultrasonic single frequency transducers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 40 kHz</em>) – The resonant frequency of the transducer.</li>
<li><strong>p0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 6 Pa</em>) – The sound pressure crated at maximum amplitude at 1m distance, in Pa.</li>
<li><strong>**kwargs</strong> – All remaining arguments will be used as additional properties for the object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wavenumber in air.</li>
<li><strong>wavelength</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wavelength in air.</li>
<li><strong>omega</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Angular frequency.</li>
<li><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Wave frequency.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.transducers.TransducerModel.greens_function">
<code class="descname">greens_function</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.greens_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the transducer radiation.</p>
<p>This is a combination of spherically spreading waves, a directivity
function, and a source strength.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation. The last dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The pressure at the locations, assuming <code class="xref py py-obj docutils literal notranslate"><span class="pre">p0</span></code> as the source strength.
Has the same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> with the last axis removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.spherical_spreading">
<code class="descname">spherical_spreading</code><span class="sig-paren">(</span><em>source_position</em>, <em>receiver_position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.spherical_spreading" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate spherical wavefronts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate. The last dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The amplitude and phase of the wavefront, assuming 1Pa at 1m distance,
phase referenced to the transducer center.
Has the same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> with the last axis removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.directivity">
<code class="descname">directivity</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.directivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Subclasses will preferably implement this to create new directivity models.
Default implementation is omnidirectional sources.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the directivity. The last dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The amplitude (and phase) of the directivity, assuming 1Pa at 1m distance,
phase referenced to the transducer center.
Has the same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> with the last axis removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the greens function.</p>
<p>This is the combination of the derivative of the spherical spreading, and
the derivatives of the directivity, including source strength.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the derivatives. The last dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are the same as the <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> input with the last dimension removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.spherical_derivatives">
<code class="descname">spherical_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>receiver_position</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.spherical_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the spherical spreading.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the derivatives. The last dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are the same as the <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> input with the last dimension removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.directivity_derivatives">
<code class="descname">directivity_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.directivity_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the directivity.</p>
<p>The default implementation uses finite difference stencils to evaluate the
derivatives. In principle this means that customized directivity models
does not need to implement their own derivatives, but can do so for speed
and precision benefits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the derivatives. The last dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are the same as the <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> input with the last dimension removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.ReflectingTransducer">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">ReflectingTransducer</code><span class="sig-paren">(</span><em>ctype</em>, <em>plane_distance</em>, <em>plane_normal=(0</em>, <em>0</em>, <em>1)</em>, <em>reflection_coefficient=1</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.ReflectingTransducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Metaclass for transducers with planar reflectors.</p>
<p>This class can be used to add reflectors to all transducer models.
This uses the image source method, so only infinite planar reflectors are
possible.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ctype</strong> (<em>class</em>) – The class implementing the transducer model.</li>
<li><strong>plane_distance</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The distance between the array and the reflector, along the normal.</li>
<li><strong>plane_normal</strong> (<em>array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>,</em><em>0</em><em>,</em><em>1</em><em>)</em>) – 3 element vector with the plane normal.</li>
<li><strong>reflection_coefficient</strong> (<em>complex float</em><em>, </em><em>default 1</em>) – Reflection coefficient to tune the magnitude and phase of the reflection.</li>
<li><strong>*args</strong> – Passed to ctype initializer</li>
<li><strong>**kwargs</strong> – Passed to ctype initializer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>transducer</em> – An object of a dynamically created class, inheriting from ReflectingTransducer and ctype.</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.transducers.ReflectingTransducer.greens_function">
<code class="descname">greens_function</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.ReflectingTransducer.greens_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the transducer radiation.</p>
<p>This evaluates the Green’s function for the underlying transducer model,
using the main source and the image source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation. The last dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The pressure at the locations, assuming <code class="xref py py-obj docutils literal notranslate"><span class="pre">p0</span></code> as the source strength.
Has the same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> with the last axis removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.ReflectingTransducer.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.ReflectingTransducer.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the transducer radiation.</p>
<p>This calculates the spatial derivatives for the underlying transducer model,
using the main source and the image source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the derivatives. The last dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are the same as the <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> input with the last dimension removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.PlaneWaveTransducer">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">PlaneWaveTransducer</code><span class="sig-paren">(</span><em>freq=40000.0</em>, <em>p0=6</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PlaneWaveTransducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing planar waves.</p>
<p>This is not representing a physical transducer per se, but a traveling
plane wave.</p>
<dl class="method">
<dt id="levitate.transducers.PlaneWaveTransducer.greens_function">
<code class="descname">greens_function</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PlaneWaveTransducer.greens_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the pressure at a point.</p>
<p>The equation is that of a plane wave, <span class="math notranslate nohighlight">\(G(\vec x) = p_0 \exp(j\vec k \cdot \vec x)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the radiation. The last dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The pressure at the locations, assuming <code class="xref py py-obj docutils literal notranslate"><span class="pre">p0</span></code> as the source strength.
Has the same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> with the last axis removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.PlaneWaveTransducer.spatial_derivatives">
<code class="descname">spatial_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PlaneWaveTransducer.spatial_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the greens function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the derivatives. The last dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are the same as the <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> input with the last dimension removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.CircularPiston">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">CircularPiston</code><span class="sig-paren">(</span><em>effective_radius</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularPiston" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular piston transducer model.</p>
<p>Implementation of the circular piston directivity <span class="math notranslate nohighlight">\(D(\theta) = 2 J_1(ka\sin\theta) / (ka\sin\theta)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>effective_radius</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The radius <span class="math notranslate nohighlight">\(a\)</span> in the above.</li>
<li><strong>**kwargs</strong> – See <a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerModel</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.transducers.CircularPiston.directivity">
<code class="descname">directivity</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularPiston.directivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Returns <span class="math notranslate nohighlight">\(D(\theta) = 2 J_1(ka\sin\theta) / (ka\sin\theta)\)</span>
where <span class="math notranslate nohighlight">\(a\)</span> is the <code class="xref py py-obj docutils literal notranslate"><span class="pre">effective_radius</span></code> of the transducer,
<span class="math notranslate nohighlight">\(k\)</span> is the wavenumber of the transducer (<code class="xref py py-obj docutils literal notranslate"><span class="pre">k</span></code>),
<span class="math notranslate nohighlight">\(\theta\)</span> is the angle between the transducer normal
and the vector from the transducer to the receiving point,
and and <span class="math notranslate nohighlight">\(J_1\)</span> is the first order Bessel function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the directivity. The last dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The amplitude (and phase) of the directivity, assuming 1Pa at 1m distance,
phase referenced to the transducer center.
Has the same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> with the last axis removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.CircularRing">
<em class="property">class </em><code class="descclassname">levitate.transducers.</code><code class="descname">CircularRing</code><span class="sig-paren">(</span><em>effective_radius</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular ring transducer model.</p>
<p>Implementation of the circular ring directivity <span class="math notranslate nohighlight">\(D(\theta) = J_0(ka\sin\theta)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>effective_radius</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The radius <span class="math notranslate nohighlight">\(a\)</span> in the above.</li>
<li><strong>**kwargs</strong> – See <a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerModel</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.transducers.CircularRing.directivity">
<code class="descname">directivity</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing.directivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Returns <span class="math notranslate nohighlight">\(D(\theta) = J_0(ka\sin\theta)\)</span> where
<span class="math notranslate nohighlight">\(a\)</span> is the <code class="xref py py-obj docutils literal notranslate"><span class="pre">effective_radius</span></code> of the transducer,
<span class="math notranslate nohighlight">\(k\)</span> is the wavenumber of the transducer (<code class="xref py py-obj docutils literal notranslate"><span class="pre">k</span></code>),
<span class="math notranslate nohighlight">\(\theta\)</span> is the angle between the transducer normal
and the vector from the transducer to the receiving point,
and <span class="math notranslate nohighlight">\(J_0\)</span> is the zeroth order Bessel function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the directivity. The last dimension must have length 3 and represent the coordinates of the points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>numpy.ndarray</em>) – The amplitude (and phase) of the directivity, assuming 1Pa at 1m distance,
phase referenced to the transducer center.
Has the same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> with the last axis removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.CircularRing.directivity_derivatives">
<code class="descname">directivity_derivatives</code><span class="sig-paren">(</span><em>source_position</em>, <em>source_normal</em>, <em>receiver_position</em>, <em>orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing.directivity_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spatial derivatives of the directivity.</p>
<p>Explicit implementation of the derivatives of the directivity, based
on analytical differentiation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location of the transducer, as a 3 element array.</li>
<li><strong>source_normal</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The look direction of the transducer, as a 3 element array.</li>
<li><strong>receiver_position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – The location(s) at which to evaluate the derivatives. The last dimension must have length 3 and represent the coordinates of the points.</li>
<li><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – How many orders of derivatives to calculate. Currently three orders are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>derivatives</strong> (<em>numpy.ndarray</em>) – Array with the calculated derivatives. Has the shape (M,…) where M is the number of spatial
derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>, and the remaining
dimensions are the same as the <code class="xref py py-obj docutils literal notranslate"><span class="pre">receiver_position</span></code> input with the last dimension removed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-levitate.cost_functions">
<span id="cost-functions"></span><h2>Cost Functions<a class="headerlink" href="#module-levitate.cost_functions" title="Permalink to this headline">¶</a></h2>
<p>A collection of cost functions, and a minimizer for them.</p>
<dl class="function">
<dt id="levitate.cost_functions.minimize">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">minimize</code><span class="sig-paren">(</span><em>functions</em>, <em>array</em>, <em>variable_amplitudes=False</em>, <em>constrain_transducers=None</em>, <em>callback=None</em>, <em>precall=None</em>, <em>basinhopping=False</em>, <em>return_optim_status=False</em>, <em>minimize_kwargs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimizes a set of cost functions.</p>
<p>Each cost function should have the signature <code class="xref py py-obj docutils literal notranslate"><span class="pre">f(phases,</span> <span class="pre">amplitudes)</span></code>
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">phases</span></code> is an ndarray with the phase of each element in the array,
and <code class="xref py py-obj docutils literal notranslate"><span class="pre">amplitudes</span></code> is an array with the amplitude of each element in the array.
The functions should return <code class="xref py py-obj docutils literal notranslate"><span class="pre">value,</span> <span class="pre">phase_jacobian,</span> <span class="pre">amplitude_jacobian</span></code>
where the two jacobians are the derivative of the value w.r.t each input.
If the jacobians does not exist, set <code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize_kwargs['jac']</span> <span class="pre">=</span> <span class="pre">False</span></code> and
return only <code class="xref py py-obj docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>This function supports minimization sequences. Pass an iterable of iterables
of cost functions to start sequenced minimization, e.g. a list of lists of
functions.
When using multiple cost functions, either all functions return the
jacobians, or no functions return jacobians.
The arguments: <code class="xref py py-obj docutils literal notranslate"><span class="pre">variable_amplitudes</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">constrain_transducers</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">callback</span></code>,
<code class="xref py py-obj docutils literal notranslate"><span class="pre">precall</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">basinhopping</span></code>, and  <code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize_kwargs</span></code> can be given as single
values or as iterables of the same length as <code class="xref py py-obj docutils literal notranslate"><span class="pre">functions</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>functions</strong> – The cost functions that should be minimized. A single callable, an
iterable of callables, or an iterable of iterables of callables, as
described above.</li>
<li><strong>array</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code>) – The array from which the cost functions are created.</li>
<li><strong>variable_amplitudes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Toggles the usage of varying amplitudes in the minimization.</li>
<li><strong>constrain_transducers</strong> (<em>array_like</em>) – Specifies a number of transducers which are constant elements in the
minimization. Will be used as the second argument in <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.delete</span></code></li>
<li><strong>callback</strong> (<em>callable</em>) – A callback function which will be called after each step in sequenced
minimization. Return false from the callback to break the sequence.
Should have the signature :
<code class="xref py py-obj docutils literal notranslate"><span class="pre">callback(array=array,</span> <span class="pre">result=result,</span> <span class="pre">optim_status=opt_res,</span> <span class="pre">idx=idx)</span></code></li>
<li><strong>precall</strong> (<em>callable</em>) – Initialization function which will be called with the array phases,
amplitudes, and the sequence index before each sequence step.
Must return the initial phases and amplitudes for the sequence step.
Default sets the phases and amplitudes to the solution of the previous
sequence step, or the original state for the first iteration.
Should have the signature :
<code class="xref py py-obj docutils literal notranslate"><span class="pre">precall(phases,</span> <span class="pre">amplitudes,</span> <span class="pre">idx)</span></code></li>
<li><strong>basinhopping</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Specifies if basinhopping should be used. Pass an int to specify the
number of basinhopping iterations, or True to use default value.</li>
<li><strong>return_optim_status</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Toggles the <code class="xref py py-obj docutils literal notranslate"><span class="pre">optim_status</span></code> output.</li>
<li><strong>minimize_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – Extra keyword arguments which will be passed to <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.minimize</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>result</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray</span></code>) – The array phases and amplitudes after minimization.
Stacks sequenced result in the first dimension.</li>
<li><strong>optim_status</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimizeResult</span></code>) – Scipy optimization result structure. Optional output,
toggle with the corresponding input argument.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.vector_target">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">vector_target</code><span class="sig-paren">(</span><em>vector_calculator</em>, <em>target_vector=(0</em>, <em>0</em>, <em>0)</em>, <em>weights=(1</em>, <em>1</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.vector_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function which calculates the weighted squared difference between a target vector and a varying vector.</p>
<p>This can create cost functions representing <span class="math notranslate nohighlight">\(||(v - v_0)||^2_w\)</span>, i.e.
the weighted square norm between a varying vector and a fixed vector.
Note that the values in the weights will be squared, i.e. have the inverse
unit compared to the vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vector_calculator</strong> (<em>callable</em>) – A function which calculates the varying vector from array phases and
amplitudes, along with the jacobian of said varying vector.
This function must return <code class="xref py py-obj docutils literal notranslate"><span class="pre">(v,</span> <span class="pre">dv_p,</span> <span class="pre">dv_a)</span></code>, where <code class="xref py py-obj docutils literal notranslate"><span class="pre">v</span></code> is a 3 element ndarray,
and <code class="xref py py-obj docutils literal notranslate"><span class="pre">dv_p</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">dv_a</span></code> are shape 3xn ndarrays with the phase and amplitude
jacobians. Suitable functions can be created by passing <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a> as weights
to other cost function generators in this module.</li>
<li><strong>target_vector</strong> (<em>3 element numeric</em><em>, </em><em>default</em><em> (</em><em>0</em><em>, </em><em>0</em><em>, </em><em>0</em><em>)</em>) – The fixed target vector, should be a 3 element ndarray or a scalar.</li>
<li><strong>weights</strong> (<em>3 element numeric</em><em>, </em><em>default</em><em> (</em><em>1</em><em>, </em><em>1</em><em>, </em><em>1</em><em>)</em>) – Specifies how the three parts should be weighted in the calculation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>vector_target</strong> (<em>callable</em>) – A function which given phases and optional amplitudes for an array
evaluates the above equation, as well as the jacobian of said equation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.create_weighted_cost_function">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">create_weighted_cost_function</code><span class="sig-paren">(</span><em>calc_values</em>, <em>calc_jacobian</em>, <em>spatial_derivatives</em>, <em>weights</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.create_weighted_cost_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Create weighted cost function.</p>
<p>Utility function for creating cost functions based on common conventions for
the weights and output formats. The <code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code> argument specifies what the
new function should output.</p>
<ol class="arabic simple">
<li><code class="xref py py-obj docutils literal notranslate"><span class="pre">weights=None</span></code>: No weighting is done, and no calculation of the jacobians.
The function will return the unweighted parts of the cost function.</li>
<li><code class="xref py py-obj docutils literal notranslate"><span class="pre">weights=False</span></code>: No weighting is done, but the jacobians are calculated.
The function will return <code class="xref py py-obj docutils literal notranslate"><span class="pre">(values,</span> <span class="pre">phase_jacobians,</span> <span class="pre">amplitudes_jacobians)</span></code>
where each part of the cost function is separated.</li>
<li>weights is numeric array_like: The parts of the cost function and the
jacobians are weighted and summed with their corresponding weights.
Otherwise the outputs are as in 2).</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>calc_values</strong> (<em>callable</em>) – Function accepting the total derivatives in the field, returning
the unweighted parts of the cost function.</li>
<li><strong>calc_jacobian</strong> (<em>callable</em>) – Function accepting the individual and total derivatives in the field,
returning the unweighted jacobians of the cost function.</li>
<li><strong>spatial_derivatives</strong> (<em>ndarray</em>) – The spatial derivatives needed for the calculations.</li>
<li><strong>weights</strong> (<em>array_like</em>) – The weights for the individual parts in the cost function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>cost_function</strong> (<em>callable</em>) – A function with variable return according to weights.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.gorkov_divergence">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">gorkov_divergence</code><span class="sig-paren">(</span><em>array</em>, <em>location=None</em>, <em>weights=None</em>, <em>spatial_derivatives=None</em>, <em>c_sphere=2350</em>, <em>rho_sphere=25</em>, <em>radius_sphere=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.gorkov_divergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a gorkov_divergence calculation function.</p>
<p>Creates a function, which calculates the divergence and the jacobian of the field
generated by the array at the given location when given the phases and optional
the amplitudes and return them according to mode.</p>
<dl class="docutils">
<dt>Modes:</dt>
<dd><ol class="first last arabic simple">
<li>weights = None: returns the x, y and z derivatives as a numpy array</li>
<li>weights = False: returns the derivatives as an array and the jacobian as a 3 x num_transducers 2darray as a tuple</li>
<li>else: returns the weighted sum of the divergence and the corresponding jacobian</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array</li>
<li><strong>location</strong> (<em>ndarray</em>) – Point(s) to calculate the divergence at</li>
<li><strong>weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>(</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>) or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Variable used for mode selection and providing of weights if they apply</li>
<li><strong>spatial_derivatives</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Derivatives to be used if not the default ones</li>
<li><strong>c_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 2350</em>) – Speed of sound in Polystyrene (the material used to be floated)</li>
<li><strong>rho_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 25</em>) – Density of the Styrofoam balls. Note: Isn’t it technically incorrect to assume
the speed of sound in polystyrene for the whole ball while it only contains small
amounts of it as evidenced by the density of the balls?</li>
<li><strong>radius_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 1e-3</em>) – Radius of the Styrofoam balls used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>gorkov_divergence</strong> (<em>func</em>) – The function described above</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.gorkov_laplacian">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">gorkov_laplacian</code><span class="sig-paren">(</span><em>array</em>, <em>location=None</em>, <em>weights=None</em>, <em>spatial_derivatives=None</em>, <em>c_sphere=2350</em>, <em>rho_sphere=25</em>, <em>radius_sphere=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.gorkov_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a gorkov_laplacian calculation function.</p>
<p>Creates a function, which calculates the Laplacian and the jacobian of the field
generated by the array at the given location when given the phases and optional
the amplitudes and return them according to mode.</p>
<dl class="docutils">
<dt>Modes:</dt>
<dd><ol class="first last arabic simple">
<li>weights = None: returns the x, y and z second derivatives as a numpy array</li>
<li>weights = False: returns the second derivatives as an array and the jacobian as a 3 x num_transducers 2darray as a tuple</li>
<li>else: returns the weighted Laplacian and the corresponding jacobian</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array</li>
<li><strong>location</strong> (<em>ndarray</em>) – Point(s) to calculate the laplacian at</li>
<li><strong>weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>(</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>) or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Variable used for mode selection and providing of weights if they apply</li>
<li><strong>spatial_derivatives</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Derivatives to be used if not the default ones</li>
<li><strong>c_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 2350</em>) – Speed of sound in Polystyrene (the material used to be floated)</li>
<li><strong>rho_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 25</em>) – Density of the Styrofoam balls.</li>
<li><strong>radius_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 1e-3</em>) – Radius of the Styrofoam balls used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>gorkov_laplacian</strong> (<em>func</em>) – The function described above</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.second_order_force">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">second_order_force</code><span class="sig-paren">(</span><em>array</em>, <em>location=None</em>, <em>weights=None</em>, <em>spatial_derivatives=None</em>, <em>c_sphere=2350</em>, <em>rho_sphere=25</em>, <em>radius_sphere=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.second_order_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a second_order_force calculation function.</p>
<p>Creates a function, which calculates the radiation force on a sphere
generated by the array at the given location when given the phases and optional
the amplitudes and return them according to mode.</p>
<p>This is more suitable than the Gor’kov formulation for use with progressive
wave fiends, e.g. single sided arrays, see <a class="reference external" href="https://doi.org/10.1121/1.4773924">https://doi.org/10.1121/1.4773924</a>.</p>
<dl class="docutils">
<dt>Modes:</dt>
<dd><ol class="first last arabic simple">
<li>weights = None: returns the x, y and z forces as a numpy array</li>
<li>weights = False: returns the forces as an array and the jacobian as a 3 x num_transducers 2darray as a tuple</li>
<li>else: returns the weighted sum of forces and the corresponding jacobian</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array</li>
<li><strong>location</strong> (<em>ndarray</em>) – Point(s) to calculate the laplacian at</li>
<li><strong>weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>(</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>) or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Variable used for mode selection and providing of weights if they apply</li>
<li><strong>spatial_derivatives</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Derivatives to be used if not the default ones</li>
<li><strong>c_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 2350</em>) – Speed of sound in Polystyrene (the material used to be floated)</li>
<li><strong>rho_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 25</em>) – Density of the Styrofoam balls.</li>
<li><strong>radius_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 1e-3</em>) – Radius of the Styrofoam balls used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>second_order_force</strong> (<em>func</em>) – The function described above</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.second_order_stiffness">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">second_order_stiffness</code><span class="sig-paren">(</span><em>array</em>, <em>location=None</em>, <em>weights=None</em>, <em>spatial_derivatives=None</em>, <em>c_sphere=2350</em>, <em>rho_sphere=25</em>, <em>radius_sphere=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.second_order_stiffness" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a second_order_stiffness calculation function.</p>
<p>Creates a function, which calculates the radiation stiffness on a sphere
generated by the array at the given location when given the phases and optional
the amplitudes and return them according to mode.</p>
<p>This is more suitable than the Gor’kov formulation for use with progressive
wave fiends, e.g. single sided arrays, see <a class="reference external" href="https://doi.org/10.1121/1.4773924">https://doi.org/10.1121/1.4773924</a>.</p>
<dl class="docutils">
<dt>Modes:</dt>
<dd><ol class="first last arabic simple">
<li>weights = None: returns the x, y and z stiffness as a numpy array</li>
<li>weights = False: returns the stiffnesses as an array and the jacobian as a 3 x num_transducers 2darray as a tuple</li>
<li>else: returns the weighted the stiffness and the corresponding jacobian</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array</li>
<li><strong>location</strong> (<em>ndarray</em>) – Point(s) to calculate the laplacian at</li>
<li><strong>weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>(</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>) or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Variable used for mode selection and providing of weights if they apply</li>
<li><strong>spatial_derivatives</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Derivatives to be used if not the default ones</li>
<li><strong>c_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 2350</em>) – Speed of sound in Polystyrene (the material used to be floated)</li>
<li><strong>rho_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 25</em>) – Density of the Styrofoam balls.</li>
<li><strong>radius_sphere</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default 1e-3</em>) – Radius of the Styrofoam balls used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>second_order_stiffness</strong> (<em>func</em>) – The function described above</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.amplitude_limiting">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">amplitude_limiting</code><span class="sig-paren">(</span><em>array</em>, <em>bounds=(0.001</em>, <em>0.999)</em>, <em>order=4</em>, <em>scaling=10</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.amplitude_limiting" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an amplitude limiting cost function.</p>
<p>Creates a function which can apply additional cost for amplitudes outside
a certain range. This can be used with unbounded optimizers to enforce
virtual bounds.
The limiting is implemented as a polynomial soft-limiter. Amplitudes
outside the specified range will be multiplied with a scaling, then
raised to a certain order. The total cost is evaluated over all transducer
elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array</li>
<li><strong>bounds</strong> (<em>array_like</em>) – Specifies the bounds to which the amplitude should be limited.
Default (0.001, 0.999).</li>
<li><strong>order</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The order of the polynomial, default 4.</li>
<li><strong>scaling</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The scaling of the cost, default 10.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>amplitude_limiting</strong> (<em>func</em>) – The function described above.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.pressure">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">pressure</code><span class="sig-paren">(</span><em>array</em>, <em>location=None</em>, <em>weight=None</em>, <em>spatial_derivatives=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a pressure calculation function.</p>
<p>Creates a function, which calculates the pressure and the jacobian of the field
generated by the array at the given location when given the phases and optional
the amplitudes and return them according to mode.</p>
<dl class="docutils">
<dt>Modes:</dt>
<dd><ol class="first last arabic simple">
<li>weight = None: returns the complex pressure as a numpy array</li>
<li>weight = value: returns the squared magnitude of the pressure, weighted by the weight, and the corresponding jacobians</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array</li>
<li><strong>location</strong> (<em>ndarray</em>) – Point(s) to calculate the pressure at</li>
<li><strong>weight</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Variable used for mode selection and providing of weights if they apply</li>
<li><strong>spatial_derivatives</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Derivatives to be used if not the default ones</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>pressure</strong> (<em>func</em>) – The function described above</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.cost_functions.velocity">
<code class="descclassname">levitate.cost_functions.</code><code class="descname">velocity</code><span class="sig-paren">(</span><em>array</em>, <em>location=None</em>, <em>weights=None</em>, <em>spatial_derivatives=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.cost_functions.velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a velocity calculation function.</p>
<p>Creates a function, which calculates the sound particle velocity and the
jacobian of the field generated by the array at the given location when
given the phases and optional the amplitudes and return them according to mode.</p>
<dl class="docutils">
<dt>Modes:</dt>
<dd><ol class="first last arabic simple">
<li>weights = None: returns the complex velocity as a numpy array</li>
<li>weights = False: returns the squared magnitude of the velocity components, and the corresponding jacobians</li>
<li>else: As 2), but the weighted sum of the components</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<a class="reference internal" href="#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array</li>
<li><strong>location</strong> (<em>ndarray</em>) – Point(s) to calculate the pressure at</li>
<li><strong>weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Variable used for mode selection and providing of weights if they apply</li>
<li><strong>spatial_derivatives</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Derivatives to be used if not the default ones</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>velocity</strong> (<em>func</em>) – The function described above</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-levitate.visualize">
<span id="visualization"></span><h2>Visualization<a class="headerlink" href="#module-levitate.visualize" title="Permalink to this headline">¶</a></h2>
<p>Visualization methods based on the plotly graphing library, and some connivance functions.</p>
<dl class="function">
<dt id="levitate.visualize.dB">
<code class="descclassname">levitate.visualize.</code><code class="descname">dB</code><span class="sig-paren">(</span><em>x</em>, <em>power=False</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.dB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert ratio to decibels.</p>
<p>Converting a ratio to decibels depends on whether the ratio is a ratio
of amplitudes or a ratio of powers. For amplitudes the decibel value is
<span class="math notranslate nohighlight">\(20\log(|x|)\)</span>, while for power ratios the value is <span class="math notranslate nohighlight">\(10\log(|x|)\)</span>
where <span class="math notranslate nohighlight">\(\log\)</span> is the base 10 logarithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numeric</em>) – Linear amplitude or radio, can be complex.</li>
<li><strong>power</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>default False</em>) – Toggles if the ration is proportional to power.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>Lx</strong> (<em>numeric</em>) – The decibel value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.visualize.SPL">
<code class="descclassname">levitate.visualize.</code><code class="descname">SPL</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.SPL" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert sound pressure to sound pressure level.</p>
<p>Uses the standard reference value for airborne acoustics: 20µPa.
Note that the input is the complex rms amplitude.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> (<em>numeric</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.7)"><em>complex</em></a>) – The complex sound pressure rms amplitude.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>SPL</strong> (<em>numeric</em>) – The sound pressure level</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="levitate.visualize.SVL">
<code class="descclassname">levitate.visualize.</code><code class="descname">SVL</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.SVL" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert sound particle velocity to sound velocity level.</p>
<p>Uses the standard reference value for airborne acoustics: 20µPa
and the material properties of air from the materials module.
Note that the input is the complex rms amplitude.</p>
<p>If the first axis of the velocity input has length 3, it will be assumed to
be the three Cartesian components of the velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong> (<em>numeric</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.7)"><em>complex</em></a>) – The complex sound velocity rms amplitude, or the vector velocity.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>SVL</strong> (<em>numeric</em>) – The sound velocity level</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="levitate.visualize.Visualizer">
<em class="property">class </em><code class="descclassname">levitate.visualize.</code><code class="descname">Visualizer</code><span class="sig-paren">(</span><em>array</em>, <em>xlimits=None</em>, <em>ylimits=None</em>, <em>zlimits=None</em>, <em>resolution=10</em>, <em>constant_axis=('y'</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle array visualizations.</p>
<p>Two different style of plots are currently implemented: scalar field
visualizations and transducer visualizations. The methods return
plotly compatible dictionaries corresponding to a single trace.
The calculations are buffered, so the first plots are always slower
than successive plots. This also means that the memory usage is very large
for high-resolution plots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>array</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code>) – The transducer array to visualize.</li>
<li><strong>xlimits</strong> (<em>2 element array_like</em>) – Override for the default x limits</li>
<li><strong>ylimits</strong> (<em>2 element array_like</em>) – Override for the default y limits</li>
<li><strong>zlimits</strong> (<em>2 element array_like</em>) – Override for the default z limits</li>
<li><strong>resolution</strong> (<em>numeric</em><em>, </em><em>default 10</em>) – Resolution of the plots, in elements per wavelength.</li>
<li><strong>constant_axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – <code class="xref py py-obj docutils literal notranslate"><span class="pre">(axis,</span> <span class="pre">value)</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">axis</span></code> where <code class="xref py py-obj docutils literal notranslate"><span class="pre">axis</span></code> is in <code class="xref py py-obj docutils literal notranslate"><span class="pre">['x',</span> <span class="pre">'y',</span> <span class="pre">'z']</span></code> and indicates
which axis to keep constant in the plots. The value indicates at which value
the slice is taken. Default to <code class="xref py py-obj docutils literal notranslate"><span class="pre">('y',</span> <span class="pre">0)</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="levitate.visualize.Visualizer.scalar_field">
<code class="descname">scalar_field</code><span class="sig-paren">(</span><em>calculator</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.scalar_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate and prepare a scalar field visualization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>calculator</strong> (<em>callable</em><em> or </em><em>iterable of callables</em>) – Callable which takes a mesh as input and returns data values for every point.
If an iterable is passed, the callables will be called with the output from the
previous callable, the first one called with the mesh.</li>
<li><strong>**kwargs</strong> – Remaining keyword arguments will be added to the trace dictionary, replacing defaults.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>trace</strong> (<em>dict</em>) – A plotly style dictionary with the trace for the field.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.visualize.Visualizer.pressure">
<code class="descname">pressure</code><span class="sig-paren">(</span><em>min=130</em>, <em>max=170</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize pressure field.</p>
</dd></dl>

<dl class="method">
<dt id="levitate.visualize.Visualizer.velocity">
<code class="descname">velocity</code><span class="sig-paren">(</span><em>min=130</em>, <em>max=170</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize velocity field.</p>
</dd></dl>

<dl class="method">
<dt id="levitate.visualize.Visualizer.transducers">
<code class="descname">transducers</code><span class="sig-paren">(</span><em>data='phases'</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.transducers" title="Permalink to this definition">¶</a></dt>
<dd><p>Create transducer visualization.</p>
<p>A 3d scatter trace of the transducer elements in an array.
Uses the color of the elements to show data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerArray</span></code>) – The array to visualize.</li>
<li><strong>data</strong> (<em>'phase'</em><em>, </em><em>'amplitude'</em><em>, or </em><em>numeric</em>) – Which data to color the transducers with.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>trace</strong> (<em>dict</em>) – A plotly style dictionary with the trace for the transducers.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="levitate.visualize.Visualizer.find_trap">
<code class="descname">find_trap</code><span class="sig-paren">(</span><em>start_pos</em>, <em>tolerance=1e-05</em>, <em>time_interval=50</em>, <em>return_path=False</em>, <em>rho=25</em>, <em>radius=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.visualize.Visualizer.find_trap" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the approximate location of a levitation trap.</p>
<p>Find an approximate position of a acoustic levitation trap close to a starting point.
This is done by following the radiation force in the sound field using an differential
equation solver. The differential equation is the unphysical equation <span class="math notranslate nohighlight">\(d\vec x/dt  = \vec F(x,t)\)</span>,
i.e. interpreting the force field as a velocity field.
This works for finding the location of a trap and the field line from the starting position
to the trap position, but it can not be seen as a proper kinematic simulation of the system.</p>
<p>The solving of the above equation takes place until the whole time interval is covered,
or the tolerance is met. The tolerance is evaluated using the assumption that the force
is zero at the trap, evaluating the distance from the zero-force position using the force
gradient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start_pos</strong> (<em>array_like</em><em>, </em><em>3 elements</em>) – The starting point for the solving.</li>
<li><strong>tolerance</strong> (<em>numeric</em><em>, </em><em>default 10e-6</em>) – The approximate tolerance of the solution, i.e. how close should
the found position be to the true position, in meters.</li>
<li><strong>time_interval</strong> (<em>numeric</em><em>, </em><em>default 10</em>) – The unphysical time of the solution range in the differential equation above.</li>
<li><strong>return_path</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><em>default False</em>) – Controls if the path from the starting point to the found trap is returned.
Set to an int to specify the number of points in the path.</li>
<li><strong>rho</strong> (<em>numeric</em><em>, </em><em>default 25</em>) – The density of the spherical bead.</li>
<li><strong>radius</strong> (<em>numeric</em><em>, </em><em>default 1e-3</em>) – The radius of the spherical bead.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>trap_pos</strong> (<em>numpy.ndarray</em>) – The found trap position, or the path from the starting position to the trap position, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">return_path</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="examples.html" class="btn btn-neutral" title="Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Carl Andersson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>