

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Field Wrappers &mdash; Levitate Python Toolbox 2.2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Utilities" href="utilities.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Levitate Python Toolbox
          

          
          </a>

          
            
            
              <div class="version">
                2.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../package.html">Package Organization and Functionality</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../package.html#models">Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../package.html#algorithms">Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../package.html#visualization">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../package.html#workflow">Workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#basic-trap">Basic Trap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#field-superposition">Field Superposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#complex-setups">Complex Setups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#force-diagrams">Force Diagrams</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="transducers.html">Transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="fields.html">Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization.html">Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="utilities.html#module-levitate.visualize">Visualization</a></li>
<li class="toctree-l3"><a class="reference internal" href="utilities.html#module-levitate.materials">Materials</a></li>
<li class="toctree-l3"><a class="reference internal" href="utilities.html#module-levitate.hardware">Hardware</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Field Wrappers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-types">Basic Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#squared-types">Squared Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multifield">MultiField</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multipoint">MultiPoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-details">Implementation Details</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-list">Class list</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#public-api">Public API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Basic Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#magnitude-squared-types">Magnitude Squared Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multifields">MultiFields</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multipoints">MultiPoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#private-classes">Private Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Levitate Python Toolbox</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">API Documentation</a> &raquo;</li>
        
      <li>Field Wrappers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api_docs/field_wrappers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-levitate._field_wrappers">
<span id="id1"></span><span id="field-wrappers"></span><h1>Field Wrappers<a class="headerlink" href="#module-levitate._field_wrappers" title="Permalink to this headline">¶</a></h1>
<p>Implementation of field wrapper protocol.</p>
<p>The API for the implemented fields consists of two parts:
the actual implementation of the fields in <code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplemention</span></code>
objects, and the wrapper classes <a class="reference internal" href="#levitate._field_wrappers.FieldBase" title="levitate._field_wrappers.FieldBase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldBase</span></code></a> and its subclasses.
When objects of the <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> type is instantiated
they will automagically be wrapped inside a different object, which is
returned to the caller.
The wrapper objects are of different variants, corresponding to the use case.</p>
<p>Note that it is not intended that a user manually creates any of these objects,
since there are many pit-falls when choosing the correct type. Instead call the
implemented fields to get a basic field type and manipulate it using
the arithmetic API to create the desired functionality.
To validate that an API arithmetic manipulation actually does what was intended,
simply print the resulting object to inspect the new structure.</p>
<div class="section" id="basic-types">
<h2>Basic Types<a class="headerlink" href="#basic-types" title="Permalink to this headline">¶</a></h2>
<p>The basic type is a simple <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a>, which is the default return type from
instantiating. When called with transducer complex amplitudes and a set of positions,
the object evaluates the field implementation with the required parameters and
returns just the value from the field.</p>
<p>If the field is bound by using the <code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;</span></code> operation a new <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a>
object is created, and the position is implicit in the call.
This is more efficient for repeated calling with the same position,
since some parts of the calculation can be cached.</p>
<p>If the field is weighed with the <code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code> operation a new <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a>
object is created, and the return from a call is changed. Cost field type
objects will return the weighed sum of the different parts of the implemented
field, as well as the jacobians of said value with respect to the transducers.
The jacobians are returned if a form that allow for simple calculation of the
jacobians with respect to transducer real part, imaginary part, amplitude, or phase.</p>
<p>If a field is both bound and weighted it is a <a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a>, created either
by binding a <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a> or by weighting a <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a>.
This will have the same caching and call signature as a <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a>, but
the same return values as an <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a>. This form is the most suitable
for numerical optimizations.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a></p></td>
<td><p>Primary class for single point, single field.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a></p></td>
<td><p>Position-bound class for single point, single field.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a></p></td>
<td><p>Unbound cost field for single point, single field.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a></p></td>
<td><p>Cost function for single point, single fields.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="squared-types">
<h2>Squared Types<a class="headerlink" href="#squared-types" title="Permalink to this headline">¶</a></h2>
<p>Each of the above types can be used to change the values (and jacobians)
to calculate the squared magnitude of the values, possible with a static
target shift applied before taking the magnitude.
There are four types, <a class="reference internal" href="#levitate._field_wrappers.SquaredField" title="levitate._field_wrappers.SquaredField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredField</span></code></a>, <a class="reference internal" href="#levitate._field_wrappers.SquaredFieldPoint" title="levitate._field_wrappers.SquaredFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredFieldPoint</span></code></a>,
<a class="reference internal" href="#levitate._field_wrappers.SquaredCostField" title="levitate._field_wrappers.SquaredCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostField</span></code></a>, and <a class="reference internal" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="levitate._field_wrappers.SquaredCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostFieldPoint</span></code></a>, each
corresponding to one of the basic types.
They are created by taking the absolute value of a basic object, or by subtracting
a fixed value from a basic object. Note that the square is not apparent from the API,
which is less intuitive that the other parts in the API.
In all other regards, the squared versions behave like their basic counterparts.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate._field_wrappers.SquaredField" title="levitate._field_wrappers.SquaredField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredField</span></code></a></p></td>
<td><p>Magnitude target field class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate._field_wrappers.SquaredFieldPoint" title="levitate._field_wrappers.SquaredFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredFieldPoint</span></code></a></p></td>
<td><p>Magnitude target bound field class.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostField" title="levitate._field_wrappers.SquaredCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostField</span></code></a></p></td>
<td><p>Magnitude target unbound cost field class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="levitate._field_wrappers.SquaredCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostFieldPoint</span></code></a></p></td>
<td><p>Magnitude target cost function class.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="multifield">
<h2>MultiField<a class="headerlink" href="#multifield" title="Permalink to this headline">¶</a></h2>
<p>MultiFields are objects which collect basic fields operating at the same point(s) in space.
Two objects of the same basic type (or a squared version of said basic type)
can be added together. If the fields are either unbound or bound to the same
position, a multi-field-type object is created. Again, there are four types, each corresponding
to one of the basic types: <a class="reference internal" href="#levitate._field_wrappers.MultiField" title="levitate._field_wrappers.MultiField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiField</span></code></a>, <a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a>, <a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a>,
and <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a>.
The two field-style variants will evaluate all included fields and return the individual
values from the included fields. The two cost-field-style variants will sum the values
from the included cost fields.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate._field_wrappers.MultiField" title="levitate._field_wrappers.MultiField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiField</span></code></a></p></td>
<td><p>Class for multiple fields, single position calculations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a></p></td>
<td><p>Class for multiple field, single fixed position calculations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a></p></td>
<td><p>Class for multiple cost function, single position calculations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a></p></td>
<td><p>Class for multiple cost function, single fixed position calculations.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="multipoint">
<h2>MultiPoint<a class="headerlink" href="#multipoint" title="Permalink to this headline">¶</a></h2>
<p>MultiPoints are objects which collect multi-field-type objects bound to different points.
There are only two types: <a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a> similar to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">MutiFieldPoint</span></code>,
and <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a> similar to a <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a>. It is not possible to
have unbound multi-points, they would simply be unbound.
A <a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a> returns the values from the stored fields.
A <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a> will sum the values and jacobians of the stored objects.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a></p></td>
<td><p>Collects fields bound to different positions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a></p></td>
<td><p>Collects cost fields bound to different positions.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="implementation-details">
<h2>Implementation Details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>To make the API work as intended, there are a couple additional
classes and functions.
The base class for the implemented fields, <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> is
only used as a super class when implementing new physical fields. See its documentation
for more details on how to extend the package with new field implementations.</p>
<p>The wrapping of <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> inside <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> objects is implemented
in the <a class="reference internal" href="#levitate._field_wrappers.FieldImplementationMeta" title="levitate._field_wrappers.FieldImplementationMeta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementationMeta</span></code></a> class, in the <a class="reference internal" href="#levitate._field_wrappers.FieldImplementationMeta.__call__" title="levitate._field_wrappers.FieldImplementationMeta.__call__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code></a> method.
This also accepts additional <code class="xref py py-obj docutils literal notranslate"><span class="pre">weight</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">position</span></code> parameters to directly create
the other three basic types, instead of the default <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a>.</p>
<p><a class="reference internal" href="#levitate._field_wrappers.FieldBase" title="levitate._field_wrappers.FieldBase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldBase</span></code></a> is the top-level class for all wrappers, and handles evaluation of
spatial structures, caching, etc.
Similarly there is a <a class="reference internal" href="#levitate._field_wrappers.SquaredFieldBase" title="levitate._field_wrappers.SquaredFieldBase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredFieldBase</span></code></a>, which is wrapping the base <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> objects’
calculation functions with the magnitude and square.</p>
</div>
<div class="section" id="class-list">
<h2>Class list<a class="headerlink" href="#class-list" title="Permalink to this headline">¶</a></h2>
<div class="section" id="public-api">
<h3>Public API<a class="headerlink" href="#public-api" title="Permalink to this headline">¶</a></h3>
<p>These are the only classes and functions regarded as part of the public API,
but they will only be used directly when implementing new algorithm types.</p>
<dl class="class">
<dt id="levitate._field_wrappers.FieldImplementation">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">FieldImplementation</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldImplementation" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for FieldImplementations.</p>
<p>The attributes listed below are part of the API and should be
implemented in subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>array</strong> (<a class="reference internal" href="arrays.html#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The array object to use for calculations.</p>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>values_require</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – Each key in this dictionary specifies a requirement for
the <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation.values" title="levitate._field_wrappers.FieldImplementation.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code></a> method. The wrapper classes will manage
calling the method with the specified arguments.</p></li>
<li><p><strong>jacobians_require</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – Each key in this dictionary specifies a requirement for
the <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation.jacobians" title="levitate._field_wrappers.FieldImplementation.jacobians"><code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobians</span></code></a> method. The wrapper classes will manage
calling the method with the specified arguments.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="levitate._field_wrappers.FieldImplementation.values">
<code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldImplementation.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to calculate the value(s) for the field.</p>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.FieldImplementation.jacobians">
<code class="sig-name descname">jacobians</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldImplementation.jacobians" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to calculate the jacobians for the field.
This method is optional if the implementation is not used
as a cost function in optimizations.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>array</strong> (<a class="reference internal" href="arrays.html#levitate.arrays.TransducerArray" title="levitate.arrays.TransducerArray"><em>TransducerArray</em></a>) – The object modeling the array.</p>
</dd>
</dl>
<dl class="method">
<dt id="levitate._field_wrappers.FieldImplementation.requirement">
<em class="property">static </em><code class="sig-name descname">requirement</code><span class="sig-paren">(</span><em class="sig-param">**requirements</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldImplementation.requirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a set of requirements.</p>
<p><a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> objects should define requirements for values and jacobians.
This function parses the requirements and checks that the request can be met upon call.
Currently the inputs are converted to a dict and returned as is, but this might change
without warning in the future.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>complex_transducer_amplitudes</strong> – The field requires the actual complex transducer amplitudes directly.
This is a fallback requirement when it is not possible to implement the field
with the other requirements, and no performance optimization is possible.</p></li>
<li><p><strong>pressure_derivs_summed</strong> – The number of orders of Cartesian spatial derivatives of the total sound pressure field.
Currently implemented to third order derivatives.
See <a class="reference internal" href="utilities.html#levitate.utils.pressure_derivs_order" title="levitate.utils.pressure_derivs_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">levitate.utils.pressure_derivs_order</span></code></a> and <a class="reference internal" href="utilities.html#levitate.utils.num_pressure_derivs" title="levitate.utils.num_pressure_derivs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">levitate.utils.num_pressure_derivs</span></code></a>
for a description of the structure.</p></li>
<li><p><strong>pressure_derivs_summed</strong> – Like pressure_derivs_summed, but for individual transducers.</p></li>
<li><p><strong>spherical_harmonics_summed</strong> – A spherical harmonics decomposition of the total sound pressure field, up to and
including the order specified.
where remaining dimensions are determined by the positions.</p></li>
<li><p><strong>spherical_harmonics_individual</strong> – Like spherical_harmonics_summed, but for individual transducers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>requirements</strong> (<em>dict</em>) – The parsed requirements.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.8)"><strong>NotImplementedError</strong></a> – If one or more of the requested keys is not implemented.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id2">
<h3>Basic Types<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="levitate._field_wrappers.Field">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">Field</code><span class="sig-paren">(</span><em class="sig-param">field</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Primary class for single point, single field.</p>
<p>This is a wrapper class for <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> to simplify the manipulation
and evaluation of the implemented fields. Normally it is not necessary to manually
create the wrapper, since it should be done automagically.
Many properties are inherited from the underlying field implementation, e.g.
<code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code>, <a class="reference external" href="https://docs.python.org/3/library/array.html#module-array" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">jacobians</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a>) – The implemented field to use for calculations.</p>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds this field with another <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Weight the field with a suitable weight.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Bind the field to a point in space. The point needs to have
3 elements in the first dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Converts to a squared magnitude target field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredField" title="levitate._field_wrappers.SquaredField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.Field.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em>, <em class="sig-param">position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.Field.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the field implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>compelx_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p></li>
<li><p><strong>position</strong> (<em>array-like</em>) – The position(s) where to evaluate the field.
The first dimension needs to have 3 elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>values</strong> (<em>ndarray</em>) – The values of the implemented field used to create the wrapper.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.FieldPoint">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">FieldPoint</code><span class="sig-paren">(</span><em class="sig-param">field</em>, <em class="sig-param">position</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Position-bound class for single point, single field.</p>
<p>See <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> for more precise description.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><em>FieldImplementation</em></a>) – The implemented field to use for calculations.</p></li>
<li><p><strong>position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – The position to bind to.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds this field with another <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a>,
<a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a>, or <a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Weight the field with a suitable weight.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Re-bind the field to a new point in space. The point needs to have
3 elements in the first dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Converts to a magnitude target field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredFieldPoint" title="levitate._field_wrappers.SquaredFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.FieldPoint.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldPoint.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the field implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>compelx_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>values</strong> (<em>ndarray</em>) – The values of the implemented field used to create the wrapper.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.CostField">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">CostField</code><span class="sig-paren">(</span><em class="sig-param">field</em>, <em class="sig-param">weight</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.CostField" title="Permalink to this definition">¶</a></dt>
<dd><p>Unbound cost field for single point, single field.</p>
<p>See <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> for more precise description.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><em>FieldImplementation</em></a>) – The implemented field to use for calculations.</p></li>
<li><p><strong>weight</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – The weight to use for the summation of values. Needs to have the same
number of dimensions as the <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> used.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds this field with another <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Rescale the weight, i.e. multiplies the current weight with the new value.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Bind the field to a point in space. The point needs to have
3 elements in the first dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Converts to a squared magnitude target field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostField" title="levitate._field_wrappers.SquaredCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.CostField.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em>, <em class="sig-param">position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.CostField.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the field implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>compelx_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p></li>
<li><p><strong>position</strong> (<em>array-like</em>) – The position(s) where to evaluate the field.
The first dimension needs to have 3 elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>values</strong> (<em>ndarray</em>) – The values of the implemented fiield used to create the wrapper.</p></li>
<li><p><strong>jacobians</strong> (<em>ndarray</em>) – The jacobians of the values with respect to the transducers.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.CostFieldPoint">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">CostFieldPoint</code><span class="sig-paren">(</span><em class="sig-param">field</em>, <em class="sig-param">weight</em>, <em class="sig-param">position</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.CostFieldPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Cost function for single point, single fields.</p>
<p>See <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> for more precise description.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><em>FieldImplementation</em></a>) – The implemented field to use for calculations.</p></li>
<li><p><strong>weight</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – The weight to use for the summation of values. Needs to have the same
number of dimensions as the <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> used.</p></li>
<li><p><strong>position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – The position to bind to.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds this field with another <a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a>,
<a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a>, or <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a>,or <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Rescale the weight, i.e. multiplies the current weight with the new value.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Re-bind the field to a new point in space. The point needs to have
3 elements in the first dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Converts to a magnitude target field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="levitate._field_wrappers.SquaredCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.CostFieldPoint.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.CostFieldPoint.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the field implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>complex_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>values</strong> (<em>ndarray</em>) – The values of the implemented field used to create the wrapper.</p></li>
<li><p><strong>jacobians</strong> (<em>ndarray</em>) – The jacobians of the values with respect to the transducers.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="magnitude-squared-types">
<h3>Magnitude Squared Types<a class="headerlink" href="#magnitude-squared-types" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="levitate._field_wrappers.SquaredFieldBase">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">SquaredFieldBase</code><span class="sig-paren">(</span><em class="sig-param">field</em>, <em class="sig-param">target</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.SquaredFieldBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for magnitude target fields.</p>
<p>Uses a field  <span class="math notranslate nohighlight">\(A\)</span> to instead calculate <span class="math notranslate nohighlight">\(V = |A - A_0|^2\)</span>,
i.e. the squared magnitude difference to a target. For multi-dimensional fields
the target needs to have the same (or a broadcastable) shape.
The jacobians are calculated as <span class="math notranslate nohighlight">\(dV = 2 dA (A-A_0)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<em>Field-like</em>) – A wrapper of a field implementation, of the same type as the magnitude target.</p></li>
<li><p><strong>numpy.ndarray</strong> (<em>target</em>) – The static offset target value(s).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class should not be instantiated directly, only use subclasses.</p>
</div>
<dl class="method">
<dt id="levitate._field_wrappers.SquaredFieldBase.values">
<code class="sig-name descname">values</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.SquaredFieldBase.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate squared magnitude difference.</p>
<p>If the underlying field returns <span class="math notranslate nohighlight">\(A\)</span>, this function returns
<span class="math notranslate nohighlight">\(|A - A_0|^2\)</span>, where <span class="math notranslate nohighlight">\(A_0\)</span> is the target value.</p>
<p>For information about parameters, see the documentation of the values function
of the underlying objects, accessed through the <code class="xref py py-obj docutils literal notranslate"><span class="pre">field</span></code> properties.</p>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.SquaredFieldBase.jacobians">
<code class="sig-name descname">jacobians</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.SquaredFieldBase.jacobians" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate jacobians squared magnitude difference.</p>
<p>If the underlying field returns <span class="math notranslate nohighlight">\(dA\)</span>, the derivative of the value(s)
with respect to the transducers, this function returns
<span class="math notranslate nohighlight">\(2 dA (A - A_0)\)</span>, where <span class="math notranslate nohighlight">\(A_0\)</span> is the target value.</p>
<p>For information about parameters, see the documentation of the values function
of the underlying objects, accessed through the <code class="xref py py-obj docutils literal notranslate"><span class="pre">field</span></code> properties.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.SquaredField">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">SquaredField</code><span class="sig-paren">(</span><em class="sig-param">field</em>, <em class="sig-param">target</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.SquaredField" title="Permalink to this definition">¶</a></dt>
<dd><p>Magnitude target field class.</p>
<p>Calculates the squared magnitude difference between the field value(s)
and a static target value(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><em>Field</em></a>) – A wrapper of an field implementation.</p></li>
<li><p><strong>target</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – The static offset target value(s).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds this field with another <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiField" title="levitate._field_wrappers.MultiField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiField</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiField" title="levitate._field_wrappers.MultiField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Weight the field with a suitable weight.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostField" title="levitate._field_wrappers.SquaredCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Bind the field to a point in space. The point needs to have
3 elements in the first dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredFieldPoint" title="levitate._field_wrappers.SquaredFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Shifts the current target value(s) with the new values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredField" title="levitate._field_wrappers.SquaredField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredField</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.SquaredFieldPoint">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">SquaredFieldPoint</code><span class="sig-paren">(</span><em class="sig-param">field</em>, <em class="sig-param">target</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.SquaredFieldPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Magnitude target bound field class.</p>
<p>Calculates the squared magnitude difference between the field value(s)
and a static target value(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><em>FieldPoint</em></a>) – A wrapper of an field implementation.</p></li>
<li><p><strong>target</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – The static offset target value(s).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds this field with another <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a>,
<a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a>, or <a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a>, or <a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Weight the field with a suitable weight.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="levitate._field_wrappers.SquaredCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Re-bind the field to a point in space. The point needs to have
3 elements in the first dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredFieldPoint" title="levitate._field_wrappers.SquaredFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Shifts the current target value(s) with the new values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredFieldPoint" title="levitate._field_wrappers.SquaredFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.SquaredCostField">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">SquaredCostField</code><span class="sig-paren">(</span><em class="sig-param">field</em>, <em class="sig-param">target</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.SquaredCostField" title="Permalink to this definition">¶</a></dt>
<dd><p>Magnitude target unbound cost field class.</p>
<p>Calculates the squared magnitude difference between the field value(s)
and a static target value(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><em>CostField</em></a>) – A wrapper of an field implementation.</p></li>
<li><p><strong>target</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – The static offset target value(s).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds this field with another <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Rescale the weight, i.e. multiplies the current weight with the new value.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostField" title="levitate._field_wrappers.SquaredCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Bind the field to a point in space. The point needs to have
3 elements in the first dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="levitate._field_wrappers.SquaredCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Shifts the current target value(s) with the new values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostField" title="levitate._field_wrappers.SquaredCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.SquaredCostFieldPoint">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">SquaredCostFieldPoint</code><span class="sig-paren">(</span><em class="sig-param">field</em>, <em class="sig-param">target</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Magnitude target cost function class.</p>
<p>Calculates the squared magnitude difference between the field value(s)
and a static target value(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> (<a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><em>CostFieldPoint</em></a>) – A wrapper of an field implementation.</p></li>
<li><p><strong>target</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – The static offset target value(s).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds this field with another <a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a>,
<a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a>, or <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a>, or <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Rescale the weight, i.e. multiplies the current weight with the new value.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="levitate._field_wrappers.SquaredCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Bind the field to a point in space. The point needs to have
3 elements in the first dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="levitate._field_wrappers.SquaredCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Shifts the current target value(s) with the new values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.SquaredCostFieldPoint" title="levitate._field_wrappers.SquaredCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="multifields">
<h3>MultiFields<a class="headerlink" href="#multifields" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="levitate._field_wrappers.MultiField">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">MultiField</code><span class="sig-paren">(</span><em class="sig-param">*fields</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiField" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for multiple fields, single position calculations.</p>
<p>This class collects multiple <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> objects for simultaneous evaluation at
the same position(s). Since the fields can use the same spatial structures
this is more efficient than to evaluate all the fields one by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*fields</strong> (<a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><em>Field</em></a>) – Any number of <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> objects.</p>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds an <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiField" title="levitate._field_wrappers.MultiField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiField</span></code></a> to the current set
of fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Weights all fields with the same weight. This requires
that all the fields can actually use the same weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Binds all the fields to the same position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Converts all the fields to squared target field.
This requires that all the fields can use the same target.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiField" title="levitate._field_wrappers.MultiField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.MultiField.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em>, <em class="sig-param">position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiField.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate all fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>complex_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p></li>
<li><p><strong>position</strong> (<em>array-like</em>) – The position(s) where to evaluate the fields.
The first dimension needs to have 3 elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>values</strong> (<em>list</em>) – A list of the return values from the individual fields.
Depending on the number of dimensions of the fields, the
arrays in the list might not have compatible shapes.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.MultiFieldPoint">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">MultiFieldPoint</code><span class="sig-paren">(</span><em class="sig-param">*fields</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiFieldPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for multiple field, single fixed position calculations.</p>
<p>This class collects multiple <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a> bound to the same position(s)
for simultaneous evaluation. Since the fields can use the same spatial
structures this is more efficient than to evaluate all the fields one by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*fields</strong> (<a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><em>FieldPoint</em></a>) – Any number of <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a> objects.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the class is initialized with fields bound to different points,
some of the fields are simply discarded.</p>
</div>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds an <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a> to the current set
of fields. If the newly added field is not bound to the same position,
an <code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFIeldMultiPoint</span></code> will be created and returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Weights all fields with the same weight. This requires
that all the fields can actually use the same weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Re-binds all the fields to a new position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Converts all the fields to magnitude target fields.
This requires that all the fields can use the same target.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.MultiFieldPoint.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiFieldPoint.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate all fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>compelx_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>values</strong> (<em>list</em>) – A list of the return values from the individual fields.
Depending on the number of dimensions of the fields, the
arrays in the list might not have compatible shapes.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.MultiCostField">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">MultiCostField</code><span class="sig-paren">(</span><em class="sig-param">*fields</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiCostField" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for multiple cost function, single position calculations.</p>
<p>This class collects multiple <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a> objects for simultaneous evaluation at
the same position(s). Since the fields can use the same spatial structures
this is more efficient than to evaluate all the fields one by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*fields</strong> (<a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><em>CostField</em></a>) – Any number of <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a> objects.</p>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds an <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a> to the
current set of fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Rescale the weights of all fields, i.e. multiplies the current set of
weight with the new value. The weight needs to have the correct number of
dimensions, but will otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Binds all the fields to the same position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Converts all the fields to magnitude target fields.
This requires that all the fields can use the same target.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostField" title="levitate._field_wrappers.MultiCostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostField</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.MultiCostField.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em>, <em class="sig-param">position</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiCostField.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate and sum the all fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>compelx_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p></li>
<li><p><strong>position</strong> (<em>array-like</em>) – The position(s) where to evaluate the fields.
The first dimension needs to have 3 elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>values</strong> (<em>ndarray</em>) – The summed values of all fields.</p></li>
<li><p><strong>jacobians</strong> (<em>ndarray</em>) – The the summed jacobians of all fields.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.MultiCostFieldPoint">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">MultiCostFieldPoint</code><span class="sig-paren">(</span><em class="sig-param">*fields</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiCostFieldPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for multiple cost function, single fixed position calculations.</p>
<p>This class collects multiple <a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a> bound to the same position(s)
for simultaneous evaluation. Since the fields can use the same spatial
structures this is more efficient than to evaluate all the fields one by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*fields</strong> (<a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><em>CostFieldPoint</em></a>) – Any number of <a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a> objects.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the class is initialized with fields bound to different points,
some of the fields are simply discarded.</p>
</div>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds an <a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a> to the  current set of fields.
If the newly added field is not bound to the same position,
a <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a> will be created and returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a> or <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Rescale the weights of all fields, i.e. multiplies the current set of
weight with the new value. The weight needs to have the correct number of
dimensions, but will otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">&#64;</code></dt>
<dd><p>Re-binds all the fields to a new position.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">-</code></dt>
<dd><p>Converts all the fields to magnitude target fields.
This requires that all the fields can use the same target.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.MultiCostFieldPoint.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiCostFieldPoint.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate and sum the all fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>compelx_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>values</strong> (<em>ndarray</em>) – The summed values of all cost functions.</p></li>
<li><p><strong>jacobians</strong> (<em>ndarray</em>) – The the summed jacobians of all cost functions.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="multipoints">
<h3>MultiPoints<a class="headerlink" href="#multipoints" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="levitate._field_wrappers.MultiFieldMultiPoint">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">MultiFieldMultiPoint</code><span class="sig-paren">(</span><em class="sig-param">*fields</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects fields bound to different positions.</p>
<p>Convenience class to evaluate and manipulate fields bound to
different positions in space. Will not improve the computational
efficiency beyond the gains from merging the fields bound
to the same positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*fields</strong> (<a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><em>FieldPoint</em></a><em> or </em><a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><em>MultiFieldPoint</em></a>) – Any number of fields bound to any number of points.</p>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds an additional <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a>, <a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a>
or <a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a> to the set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiFieldMultiPoint" title="levitate._field_wrappers.MultiFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Weights all fields in the set with the same weight.
Requires that they can actually be weighted with the same
weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.MultiFieldMultiPoint.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiFieldMultiPoint.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate all fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>compelx_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>values</strong> (<em>list</em>) – A list of the return values from the individual fields.
Depending on the number of dimensions of the fields, the
arrays in the list might not have compatible shapes, and some
might be lists with values corresponding to the same point in space.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.MultiCostFieldMultiPoint">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">MultiCostFieldMultiPoint</code><span class="sig-paren">(</span><em class="sig-param">*fields</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects cost fields bound to different positions.</p>
<p>Convenience class to evaluate and manipulate cost fields bound to
different positions in space. Will not improve the computational
efficiency beyond the gains from merging the fields bound
to the same positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*fields</strong> (<a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><em>CostFieldPoint</em></a><em> or </em><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldPoint" title="levitate._field_wrappers.MultiCostFieldPoint"><em>MultiCostFieldPoint</em></a>) – Any number of cost fields bound to any number of points.</p>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">+</code></dt>
<dd><p>Adds an additional <a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a>, <a class="reference internal" href="#levitate._field_wrappers.MultiFieldPoint" title="levitate._field_wrappers.MultiFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiFieldPoint</span></code></a>
or <a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a> to the set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">*</code></dt>
<dd><p>Rescale the weights, i.e. multiplies the current weights with the new value.
The weight needs to have the correct number of dimensions, but will
otherwise broadcast properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><a class="reference internal" href="#levitate._field_wrappers.MultiCostFieldMultiPoint" title="levitate._field_wrappers.MultiCostFieldMultiPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiCostFieldMultiPoint</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.MultiCostFieldMultiPoint.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.MultiCostFieldMultiPoint.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate and sum the all fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>compelx_transducer_amplitudes</strong> (<em>complex numpy.ndarray</em>) – Complex representation of the transducer phases and amplitudes of the
array used to create the field.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>values</strong> (<em>ndarray</em>) – The summed values of all cost functions.</p></li>
<li><p><strong>jacobians</strong> (<em>ndarray</em>) – The the summed jacobians of all cost functions.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="private-classes">
<h3>Private Classes<a class="headerlink" href="#private-classes" title="Permalink to this headline">¶</a></h3>
<p>These classes are not considered part of the public API, and should not appear
other than as superclasses.</p>
<dl class="class">
<dt id="levitate._field_wrappers.FieldBase">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">FieldBase</code><a class="headerlink" href="#levitate._field_wrappers.FieldBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all field type objects.</p>
<p>This wraps a few common procedures for fields,
primarily dealing with preparation and evaluation of requirements
for fields implementations.
The fields support some numeric manipulations to simplify
the creation of variants of the basic types.
Not all types of fields support all operations, and the order of
operation can matter in some cases.
If unsure if the arithmetics return the desired outcome, print the
resulting object to inspect the new structure.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class should not be instantiated directly.</p>
</div>
<dl class="method">
<dt id="levitate._field_wrappers.FieldBase._type">
<em class="property">property </em><code class="sig-name descname">_type</code><a class="headerlink" href="#levitate._field_wrappers.FieldBase._type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of the field.</p>
<p>In this context <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code></a> refers for the combination of <code class="xref py py-obj docutils literal notranslate"><span class="pre">bound</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">cost</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.FieldBase._evaluate_requirements">
<code class="sig-name descname">_evaluate_requirements</code><span class="sig-paren">(</span><em class="sig-param">complex_transducer_amplitudes</em>, <em class="sig-param">spatial_structures</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldBase._evaluate_requirements" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate requirements for given complex transducer amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>complex_transducer_amplitudes</strong> (<em>complex ndarray</em>) – The transducer phase and amplitude on complex form,
must correspond to the same array used to create the field.</p></li>
<li><p><strong>spatial_structures</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – Dictionary with the calculated spatial structures required by the field(s).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>requirements</strong> (<em>dict</em>) – Has (at least) the same fields as <code class="xref py py-obj docutils literal notranslate"><span class="pre">self.requires</span></code>, but instead of values specifying the level
of the requirement, this dict has the evaluated requirement at the positions and
transducer amplitudes specified.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate._field_wrappers.FieldBase._spatial_structures">
<code class="sig-name descname">_spatial_structures</code><span class="sig-paren">(</span><em class="sig-param">position=None</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldBase._spatial_structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spatial structures.</p>
<p>Uses <code class="xref py py-obj docutils literal notranslate"><span class="pre">self.requires</span></code> to fill a dictionary of calculated required
spatial structures at a give position to satisfy the fields(s) used
for calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>position</strong> (<em>ndarray</em>) – The position where to calculate the spatial structures needed.
Shape (3,…). If position is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a> or not passed, it is assumed
that the field is bound to a position and <code class="xref py py-obj docutils literal notranslate"><span class="pre">self.position</span></code> will be used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sptaial_structures</strong> (<em>dict</em>) – Dictionary with the spatial structures required to fulfill the evaluation
of the field(s).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fields which are bound to a position will cache the spatial structures. It is
therefore important to not manually change the position, since that will not clear the cache
and the new position is not actually used.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.FieldImplementationMeta">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">FieldImplementationMeta</code><a class="headerlink" href="#levitate._field_wrappers.FieldImplementationMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Metaclass to wrap <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> objects in <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> objects.</p>
<p>API-wise it is nice to call the implementation classes when requesting a field.
Since the behavior of the objects should change depending on if they are added etc,
it would be very difficult to keep track of both the current state and the actual field
in the same top level object. This class will upon object creation instantiate the called class,
but also instantiate and return a <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a>-type object.</p>
<dl class="method">
<dt id="levitate._field_wrappers.FieldImplementationMeta.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">*cls_args</em>, <em class="sig-param">weight=None</em>, <em class="sig-param">position=None</em>, <em class="sig-param">**cls_kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate._field_wrappers.FieldImplementationMeta.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate an <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a>-type object, using the <code class="xref py py-obj docutils literal notranslate"><span class="pre">cls</span></code> as the base field implementation.</p>
<p>The actual <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a>-type will be chosen based on which optional parameters are passed.
If no parameters are passed (default) a <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> object is returned.
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">weight</span></code> is passed a <a class="reference internal" href="#levitate._field_wrappers.CostField" title="levitate._field_wrappers.CostField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostField</span></code></a> object is returned.
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">position</span></code> is passed a <a class="reference internal" href="#levitate._field_wrappers.FieldPoint" title="levitate._field_wrappers.FieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldPoint</span></code></a> object is returned.
If both <code class="xref py py-obj docutils literal notranslate"><span class="pre">weight</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">position</span></code> is passed a <a class="reference internal" href="#levitate._field_wrappers.CostFieldPoint" title="levitate._field_wrappers.CostFieldPoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFieldPoint</span></code></a> object is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cls</strong> (<em>class</em>) – The <a class="reference internal" href="#levitate._field_wrappers.FieldImplementation" title="levitate._field_wrappers.FieldImplementation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FieldImplementation</span></code></a> class to use for calculations.</p></li>
<li><p><strong>*cls_args</strong> – Args passed to the <code class="xref py py-obj docutils literal notranslate"><span class="pre">cls</span></code>.</p></li>
<li><p><strong>weight</strong> (<em>numeric</em>) – Optional weight.</p></li>
<li><p><strong>position</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) – Optional array to bind the field to, shape (3,…).</p></li>
<li><p><strong>**cls_kwargs</strong> – Keyword arguments passed to <code class="xref py py-obj docutils literal notranslate"><span class="pre">cls</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate._field_wrappers.FieldMeta">
<em class="property">class </em><code class="sig-prename descclassname">levitate._field_wrappers.</code><code class="sig-name descname">FieldMeta</code><a class="headerlink" href="#levitate._field_wrappers.FieldMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Metaclass for <a class="reference internal" href="#levitate._field_wrappers.Field" title="levitate._field_wrappers.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a>-type objects.</p>
<p>This metaclass is only needed to make the <a class="reference internal" href="#levitate._field_wrappers.FieldMeta._type" title="levitate._field_wrappers.FieldMeta._type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_type</span></code></a> property available
at both class and instance level.</p>
<dl class="method">
<dt id="levitate._field_wrappers.FieldMeta._type">
<em class="property">property </em><code class="sig-name descname">_type</code><a class="headerlink" href="#levitate._field_wrappers.FieldMeta._type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of the field.</p>
<p>In this context <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code></a> refers for the combination of <code class="xref py py-obj docutils literal notranslate"><span class="pre">bound</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">cost</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="utilities.html" class="btn btn-neutral float-left" title="Utilities" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Carl Andersson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>