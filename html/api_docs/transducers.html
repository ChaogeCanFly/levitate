

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Transducers &mdash; Levitate Python Toolbox 2.4.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Arrays" href="arrays.html" />
    <link rel="prev" title="API Documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Levitate Python Toolbox
          

          
          </a>

          
            
            
              <div class="version">
                2.4.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../package.html">Package Organization and Functionality</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../package.html#models">Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../package.html#algorithms">Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../package.html#visualization">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../package.html#workflow">Workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#basic-trap">Basic Trap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#field-superposition">Field Superposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#complex-setups">Complex Setups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#force-diagrams">Force Diagrams</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="fields.html">Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization.html">Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="utilities.html#module-levitate.visualizers">Visualization</a></li>
<li class="toctree-l3"><a class="reference internal" href="utilities.html#module-levitate.materials">Materials</a></li>
<li class="toctree-l3"><a class="reference internal" href="utilities.html#module-levitate.hardware">Hardware</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="field_wrappers.html">Field Wrappers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="field_wrappers.html#basic-types">Basic Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="field_wrappers.html#squared-types">Squared Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="field_wrappers.html#multifield">MultiField</a></li>
<li class="toctree-l3"><a class="reference internal" href="field_wrappers.html#multipoint">MultiPoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="field_wrappers.html#implementation-details">Implementation Details</a></li>
<li class="toctree-l3"><a class="reference internal" href="field_wrappers.html#class-list">Class list</a><ul>
<li class="toctree-l4"><a class="reference internal" href="field_wrappers.html#public-api">Public API</a></li>
<li class="toctree-l4"><a class="reference internal" href="field_wrappers.html#id2">Basic Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="field_wrappers.html#magnitude-squared-types">Magnitude Squared Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="field_wrappers.html#multifields">MultiFields</a></li>
<li class="toctree-l4"><a class="reference internal" href="field_wrappers.html#multipoints">MultiPoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="field_wrappers.html#private-classes">Private Classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Levitate Python Toolbox</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">API Documentation</a> &raquo;</li>
        
      <li>Transducers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api_docs/transducers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-levitate.transducers">
<span id="transducers"></span><h1>Transducers<a class="headerlink" href="#module-levitate.transducers" title="Permalink to this headline">Â¶</a></h1>
<p>Handling of individual transducers and their directivities.</p>
<p>This module contains classes describing how individual transducer elements radiate sound,
e.g. waveforms and directivities.
This is also where the various spatial properties, e.g. derivatives, are implemented.
Most calculations in this module are fully vectorized, so the models can calculate
sound fields for any number of source positions and receiver positions at once.</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerModel</span></code></a></p></td>
<td><p>Base class for ultrasonic single frequency transducers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate.transducers.PointSource" title="levitate.transducers.PointSource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PointSource</span></code></a></p></td>
<td><p>Point source transducers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate.transducers.PlaneWaveTransducer" title="levitate.transducers.PlaneWaveTransducer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PlaneWaveTransducer</span></code></a></p></td>
<td><p>Class representing planar waves.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate.transducers.CircularPiston" title="levitate.transducers.CircularPiston"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CircularPiston</span></code></a></p></td>
<td><p>Circular piston transducer model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#levitate.transducers.CircularRing" title="levitate.transducers.CircularRing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CircularRing</span></code></a></p></td>
<td><p>Circular ring transducer model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#levitate.transducers.TransducerReflector" title="levitate.transducers.TransducerReflector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerReflector</span></code></a></p></td>
<td><p>Class for transducers with planar reflectors.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="levitate.transducers.TransducerModel">
<em class="property">class </em><code class="sig-prename descclassname">levitate.transducers.</code><code class="sig-name descname">TransducerModel</code><span class="sig-paren">(</span><em class="sig-param">freq=40000.0</em>, <em class="sig-param">p0=6</em>, <em class="sig-param">medium=Air(rho=1.204082071218662</em>, <em class="sig-param">c=343.23714360505863)</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Base class for ultrasonic single frequency transducers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>default 40 kHz</em>) â The resonant frequency of the transducer.</p></li>
<li><p><strong>p0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>default 6 Pa</em>) â The sound pressure created at maximum amplitude at 1m distance, in Pa.
Note: This is not an rms value!</p></li>
<li><p><strong>medium</strong> (<a class="reference internal" href="utilities.html#levitate.materials.Material" title="levitate.materials.Material"><em>Material</em></a>) â The medium in which the array is operating.</p></li>
</ul>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) â Wavenumber in the medium.</p></li>
<li><p><strong>wavelength</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) â Wavelength in the medium.</p></li>
<li><p><strong>omega</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) â Angular frequency.</p></li>
<li><p><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) â Wave frequency.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="levitate.transducers.TransducerModel.pressure">
<code class="sig-name descname">pressure</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.pressure" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the complex sound pressure from the transducer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> (<em>numpy.ndarray</em>) â The pressure at the locations, shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerModel.pressure_derivs">
<code class="sig-name descname">pressure_derivs</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">orders=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerModel.pressure_derivs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the spatial derivatives of the greens function.</p>
<p>Calculates Cartesian spatial derivatives of the pressure Greenâs function. Should be implemented by concrete subclasses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
<li><p><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) â How many orders of derivatives to calculate. Currently three orders are supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivatives</strong> (<em>numpy.ndarray</em>) â Array with the calculated derivatives. Has the shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">(M,)</span> <span class="pre">+</span> <span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">M</span></code> is the number of spatial derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.PointSource">
<em class="property">class </em><code class="sig-prename descclassname">levitate.transducers.</code><code class="sig-name descname">PointSource</code><span class="sig-paren">(</span><em class="sig-param">freq=40000.0</em>, <em class="sig-param">p0=6</em>, <em class="sig-param">medium=Air(rho=1.204082071218662</em>, <em class="sig-param">c=343.23714360505863)</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PointSource" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Point source transducers.</p>
<p>A point source is in this context defines as a spherically spreading wave,
optionally with a directivity. On its own this class defines a monopole,
but subclasses are free to change the directivity to other shapes.</p>
<p>The spherical spreading is defined as</p>
<div class="math notranslate nohighlight">
\[G(r) = {e^{ikr} \over r}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is the distance from the source, and <span class="math notranslate nohighlight">\(k\)</span> is the wavenumber of the wave.</p>
<dl class="method">
<dt id="levitate.transducers.PointSource.directivity">
<code class="sig-name descname">directivity</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PointSource.directivity" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Subclasses will preferably implement this to create new directivity models.
Default implementation is omnidirectional sources.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> (<em>numpy.ndarray</em>) â The amplitude (and phase) of the directivity, shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.PointSource.pressure_derivs">
<code class="sig-name descname">pressure_derivs</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">orders=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PointSource.pressure_derivs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the spatial derivatives of the greens function.</p>
<p>This is the combination of the derivative of the spherical spreading, and
the derivatives of the directivity, including source strength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
<li><p><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) â How many orders of derivatives to calculate. Currently three orders are supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivatives</strong> (<em>numpy.ndarray</em>) â Array with the calculated derivatives. Has the <code class="xref py py-obj docutils literal notranslate"><span class="pre">(M,)</span> <span class="pre">+</span> <span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">M</span></code> is the number of spatial derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.PointSource.wavefront_derivatives">
<code class="sig-name descname">wavefront_derivatives</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PointSource.wavefront_derivatives" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the spatial derivatives of the spherical spreading.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
<li><p><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) â How many orders of derivatives to calculate. Currently three orders are supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivatives</strong> (<em>ndarray</em>) â Array with the calculated derivatives. Has the shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">(M,)</span> <span class="pre">+</span> <span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">M</span></code> is the number of spatial derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.PointSource.directivity_derivatives">
<code class="sig-name descname">directivity_derivatives</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PointSource.directivity_derivatives" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the spatial derivatives of the directivity.</p>
<p>The default implementation uses finite difference stencils to evaluate the
derivatives. In principle this means that customized directivity models
does not need to implement their own derivatives, but can do so for speed
and precision benefits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
<li><p><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) â How many orders of derivatives to calculate. Currently three orders are supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivatives</strong> (<em>numpy.ndarray</em>) â Array with the calculated derivatives. Has the shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">(M,)</span> <span class="pre">+</span> <span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">M</span></code> is the number of spatial derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.PointSource.spherical_harmonics">
<code class="sig-name descname">spherical_harmonics</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">orders=0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PointSource.spherical_harmonics" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Expand sound field in spherical harmonics.</p>
<p>Performs a spherical harmonics expansion of the sound field created from the transducer model.
The expansion is centered at the receiver position(s), and calculated by translating spherical
wavefronts from the source position(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
<li><p><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) â How many orders of spherical harmonics coefficients to calculate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coefficients</strong> (<em>numpy.ndarray</em>) â Array with the calculated expansion coefficients. Has the shape
<code class="xref py py-obj docutils literal notranslate"><span class="pre">(M,)</span> <span class="pre">+</span> <span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>,
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">M=len(SphericalHarmonicsIndexer(orders))</span></code>, see <a class="reference internal" href="utilities.html#levitate.utils.SphericalHarmonicsIndexer" title="levitate.utils.SphericalHarmonicsIndexer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphericalHarmonicsIndexer</span></code></a>
for details on the structure of the coefficients.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.TransducerReflector">
<em class="property">class </em><code class="sig-prename descclassname">levitate.transducers.</code><code class="sig-name descname">TransducerReflector</code><span class="sig-paren">(</span><em class="sig-param">transducer</em>, <em class="sig-param">plane_intersect=(0</em>, <em class="sig-param">0</em>, <em class="sig-param">0)</em>, <em class="sig-param">plane_normal=(0</em>, <em class="sig-param">0</em>, <em class="sig-param">1)</em>, <em class="sig-param">reflection_coefficient=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerReflector" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Class for transducers with planar reflectors.</p>
<p>This class can be used to add reflectors to all transducer models.
This uses the image source method, so only infinite planar reflectors are
possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transducer</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">TrnsducerModel</span></code> instance or (sub)class) â The base transducer to reflect. If passed a class it will be instantiated
with the remaining arguments not used by the reflector.</p></li>
<li><p><strong>plane_intersect</strong> (<em>array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>, </em><em>0</em><em>, </em><em>0</em><em>)</em>) â A point which the reflection plane intersects.</p></li>
<li><p><strong>plane_normal</strong> (<em>array_like</em><em>, </em><em>default</em><em> (</em><em>0</em><em>,</em><em>0</em><em>,</em><em>1</em><em>)</em>) â 3 element vector with the plane normal.</p></li>
<li><p><strong>reflection_coefficient</strong> (<em>complex float</em><em>, </em><em>default 1</em>) â Reflection coefficient to tune the magnitude and phase of the reflection.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>transducer</em> â The transducer model with reflections.</p>
</dd>
</dl>
<dl class="method">
<dt id="levitate.transducers.TransducerReflector.pressure_derivs">
<code class="sig-name descname">pressure_derivs</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerReflector.pressure_derivs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the spatial derivatives of the greens function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
<li><p><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) â How many orders of derivatives to calculate. Currently three orders are supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivatives</strong> (<em>numpy.ndarray</em>) â Array with the calculated derivatives. Has the shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">(M,)</span> <span class="pre">+</span> <span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">M</span></code> is the number of spatial derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.TransducerReflector.spherical_harmonics">
<code class="sig-name descname">spherical_harmonics</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.TransducerReflector.spherical_harmonics" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Evaluate the spherical harmonics expansion at a point.</p>
<p>Mirrors the sources in the reflection plane and calculates the superposition of the expansions
from the combined sources.
For the full documentation of the parameters and output format, see the documentation of the
spherical harmonics method of the underlying transducer model.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.PlaneWaveTransducer">
<em class="property">class </em><code class="sig-prename descclassname">levitate.transducers.</code><code class="sig-name descname">PlaneWaveTransducer</code><span class="sig-paren">(</span><em class="sig-param">freq=40000.0</em>, <em class="sig-param">p0=6</em>, <em class="sig-param">medium=Air(rho=1.204082071218662</em>, <em class="sig-param">c=343.23714360505863)</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PlaneWaveTransducer" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Class representing planar waves.</p>
<p>This is not representing a physical transducer per se, but a traveling
plane wave.</p>
<dl class="method">
<dt id="levitate.transducers.PlaneWaveTransducer.pressure_derivs">
<code class="sig-name descname">pressure_derivs</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">orders=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.PlaneWaveTransducer.pressure_derivs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the spatial derivatives of the greens function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
<li><p><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) â How many orders of derivatives to calculate. Currently three orders are supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivatives</strong> (<em>numpy.ndarray</em>) â Array with the calculated derivatives. Has the shape (<code class="xref py py-obj docutils literal notranslate"><span class="pre">(M,)</span> <span class="pre">+</span> <span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">M</span></code> is the number of spatial derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.CircularPiston">
<em class="property">class </em><code class="sig-prename descclassname">levitate.transducers.</code><code class="sig-name descname">CircularPiston</code><span class="sig-paren">(</span><em class="sig-param">effective_radius</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularPiston" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Circular piston transducer model.</p>
<p>Implementation of the circular piston directivity <span class="math notranslate nohighlight">\(D(\theta) = 2 {J_1(ka\sin\theta) \over ka\sin\theta}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>effective_radius</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) â The radius <span class="math notranslate nohighlight">\(a\)</span> in the above.</p></li>
<li><p><strong>**kwargs</strong> â See <a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerModel</span></code></a></p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class has no implementation of analytic jacobians yet, and is much slower to use than other models.</p>
</div>
<dl class="method">
<dt id="levitate.transducers.CircularPiston.directivity">
<code class="sig-name descname">directivity</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularPiston.directivity" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Returns <span class="math notranslate nohighlight">\(D(\theta) = 2 J_1(ka\sin\theta) / (ka\sin\theta)\)</span>
where <span class="math notranslate nohighlight">\(a\)</span> is the <code class="xref py py-obj docutils literal notranslate"><span class="pre">effective_radius</span></code> of the transducer,
<span class="math notranslate nohighlight">\(k\)</span> is the wavenumber of the transducer (<code class="xref py py-obj docutils literal notranslate"><span class="pre">k</span></code>),
<span class="math notranslate nohighlight">\(\theta\)</span> is the angle between the transducer normal
and the vector from the transducer to the receiving point,
and and <span class="math notranslate nohighlight">\(J_1\)</span> is the first order Bessel function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> (<em>numpy.ndarray</em>) â The amplitude (and phase) of the directivity, shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="levitate.transducers.CircularRing">
<em class="property">class </em><code class="sig-prename descclassname">levitate.transducers.</code><code class="sig-name descname">CircularRing</code><span class="sig-paren">(</span><em class="sig-param">effective_radius</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Circular ring transducer model.</p>
<p>Implementation of the circular ring directivity <span class="math notranslate nohighlight">\(D(\theta) = J_0(ka\sin\theta)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>effective_radius</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) â The radius <span class="math notranslate nohighlight">\(a\)</span> in the above.</p></li>
<li><p><strong>**kwargs</strong> â See <a class="reference internal" href="#levitate.transducers.TransducerModel" title="levitate.transducers.TransducerModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransducerModel</span></code></a></p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="levitate.transducers.CircularRing.directivity">
<code class="sig-name descname">directivity</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing.directivity" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Evaluate transducer directivity.</p>
<p>Returns <span class="math notranslate nohighlight">\(D(\theta) = J_0(ka\sin\theta)\)</span> where
<span class="math notranslate nohighlight">\(a\)</span> is the <code class="xref py py-obj docutils literal notranslate"><span class="pre">effective_radius</span></code> of the transducer,
<span class="math notranslate nohighlight">\(k\)</span> is the wavenumber of the transducer (<code class="xref py py-obj docutils literal notranslate"><span class="pre">k</span></code>),
<span class="math notranslate nohighlight">\(\theta\)</span> is the angle between the transducer normal
and the vector from the transducer to the receiving point,
and <span class="math notranslate nohighlight">\(J_0\)</span> is the zeroth order Bessel function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> (<em>numpy.ndarray</em>) â The amplitude (and phase) of the directivity, shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="levitate.transducers.CircularRing.directivity_derivatives">
<code class="sig-name descname">directivity_derivatives</code><span class="sig-paren">(</span><em class="sig-param">source_positions</em>, <em class="sig-param">source_normals</em>, <em class="sig-param">receiver_positions</em>, <em class="sig-param">orders=3</em><span class="sig-paren">)</span><a class="headerlink" href="#levitate.transducers.CircularRing.directivity_derivatives" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the spatial derivatives of the directivity.</p>
<p>Explicit implementation of the derivatives of the directivity, based
on analytical differentiation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>source_normals</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The look direction of the transducer, as a (3, â¦) shape array.</p></li>
<li><p><strong>receiver_positions</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><em>numpy.ndarray</em></a>) â The location(s) at which to evaluate the radiation, shape (3, â¦).
The first dimension must have length 3 and represent the coordinates of the points.</p></li>
<li><p><strong>orders</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) â How many orders of derivatives to calculate. Currently three orders are supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>derivatives</strong> (<em>numpy.ndarray</em>) â Array with the calculated derivatives. Has the shape <code class="xref py py-obj docutils literal notranslate"><span class="pre">(M,)</span> <span class="pre">+</span> <span class="pre">source_positions.shape[1:]</span> <span class="pre">+</span> <span class="pre">receiver_positions.shape[1:]</span></code>.
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">M</span></code> is the number of spatial derivatives, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">num_spatial_derivatives</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_derivative_order</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="arrays.html" class="btn btn-neutral float-right" title="Arrays" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="API Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Carl Andersson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>